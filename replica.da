import pickle
import nacl

from message import Message


class Replica(process):
    def setup(client_processes, replica_id, config):
        self.running_state = config['initial_running_state']
        signing_key = config['replica_sks'][self.replica_id]
        self.verifying_key = config['replica_vks'][self.replica_id]  # TODO: required?
        self.replica_vks = config['replica_vks']
        self.client_vks = config['client_vks']
        self.factory = Message(self.replica_id)
        self.sign = lambda x: signing_key.sign(x)
        self.replica_processes = None
        self.is_head = self.replica_id == 1  # TODO: extract constant
        self.is_tail = self.replica_id == self.config['replica_count']
        self.next_replica = None

    def run():
        output('Started Replica {}'.format(self.replica_id))
        await(some(received(('new_configuration', _,))))
        await(False)

    def receive(msg=('new_configuration', payload)):
        output('Replica {} received other replica details'.format(self.replica_id))
        self.replica_processes = payload
        self.next_replica = None if self.is_tail else self.replica_processes[self.replica_id + 1]

    def receive(msg=('request', payload)):
        if self.is_head:
            is_verified, client_id, request_id, operation = verify_client(payload)
            if is_verified:
                handle_client_request(client_id, request_id, operation)

    def receive(msg=('request_shuttle', payload)):
        if not self.is_head:
            # TODO: sender_replica_id required?
            is_verified, sender_replica_id, payload = verify_replica(payload)
            if is_verified:
                output('Replica {} : Received Request Shuttle from Replica {}, Payload: {}'.format(
                    self.replica_id, sender_replica_id, payload))
                prev_req_shuttle = parse_request_shuttle(payload)
                handle_request_shuttle(prev_req_shuttle)

    def handle_client_request(client_id, request_id, operation):
        output('Replica {} : Received Client Request, Payload: {}'.format(self.replica_id,
                                                                          operation))
        order_statement = self.factory.new_order_statement(operation)
        new_order_proof_details = {
            'client_id': client_id,
            'request_id': request_id,
            'slot': order_statement['slot'],
            'operation': operation,
            'configuration': 'DEFAULT',
            'order_statements': []
        }
        # TODO: suspend on invalid operation request?
        result = apply_operation(operation)
        empty_order_proof = self.factory.OrderProof(**new_order_proof_details)
        order_proof = self.factory.new_order_proof(empty_order_proof, order_statement)
        result_statement = self.factory.new_result_statement(operation, result)
        new_result_proof_details = {
            'client_id': client_id,
            'request_id': request_id,
            'result': result_statement['result'],
            'operation': operation,
            'configuration': 'DEFAULT',
            'result_statements': []
        }
        empty_result_proof = self.factory.ResultProof(**new_result_proof_details)
        result_proof = self.factory.new_result_proof(empty_result_proof, result_statement)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof}
        request_shuttle = self.factory.new_request_shuttle(serialize_and_sign(request_shuttle_payload))
        forward_request(request_shuttle)
        output_running_state()

    def parse_request_shuttle(payload):
        order_proof = self.factory.OrderProof(**payload['order_proof'])
        result_proof = self.factory.ResultProof(**payload['result_proof'])
        return self.factory.RequestShuttle(order_proof, result_proof)

    def handle_request_shuttle(prev_req_shuttle):
        # TODO: verify order_proof
        prev_order_proof, prev_result_proof = prev_req_shuttle.order_proof, prev_req_shuttle.result_proof
        client_id, operation = prev_order_proof.client_id, prev_order_proof.operation
        order_statement = self.factory.new_order_statement(prev_order_proof.operation, prev_order_proof.slot)
        order_proof = self.factory.new_order_proof(prev_order_proof, order_statement)
        result = apply_operation(operation)
        result_statement = self.factory.new_result_statement(operation, result)
        result_proof = self.factory.new_result_proof(prev_result_proof, result_statement)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof}
        request_shuttle = self.factory.new_request_shuttle(serialize_and_sign(request_shuttle_payload))
        forward_request(request_shuttle)
        if self.is_tail:
            response_message = bytes(result, 'utf-8')
            output('Replica {} : Sending Response to client'.format(self.replica_id))
            respond_to_client(client_id, response_message)
        output_running_state()

    def serialize_and_sign(payload):
        serialized_payload = pickle.dumps(payload)
        return self.sign(serialized_payload)

    def forward_request(request_shuttle):
        if not self.is_tail:
            output('Replica {} : forwarding request to Replica: {}'.format(self.replica_id, self.replica_id + 1))
            send(request_shuttle, to=self.next_replica)

    def apply_operation(payload):
        operation = payload['operation']
        if operation == 'put':
            return self.running_state.put(payload['key'], payload['val'])
        elif operation == 'get':
            return self.running_state.get(payload['key'])
        elif operation == 'append':
            return self.running_state.append(payload['key'], payload['val'])
        elif operation == 'slice':
            return self.running_state.slice(payload['key'], payload['slice'])
            # TODO: handle unrecognized operation?

    def respond_to_client(client_id, response_message):
        response = self.factory.new_response(self.sign(response_message))
        client_process = self.client_processes[client_id]
        send(response, to=client_process)
        output("Replica {} : Responded to client with : {}".format(self.replica_id, response_message))

    def verify_client(payload):
        client_id, request_id, signed_payload = payload['id'], payload['request_id'], payload['payload']
        try:
            if client_id in self.client_vks:
                raw_message = self.client_vks[client_id].verify(signed_payload)
                unsigned_payload = pickle.loads(raw_message)
                return True, client_id, request_id, unsigned_payload  # TODO: fix naming inconsistency
            return False, None
        except nacl.exceptions.BadSignatureError:
            return False, None

    def verify_replica(payload):
        sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
        try:
            if sender_replica_id in self.replica_vks:
                raw_message = self.replica_vks[sender_replica_id].verify(signed_payload)
                unsigned_payload = pickle.loads(raw_message)
                return True, sender_replica_id, unsigned_payload  # TODO: fix naming inconsistency
            return False, None
        except nacl.exceptions.BadSignatureError:
            return False, None

    def output_running_state():
        output('Replica {} : Running State: {}'.format(self.replica_id, self.running_state))
