import pickle
import time

import testutil
import operation as op
from constants import Mode
from message import Message
from slot import Slot
import nacl
import nacl.hash
import nacl.encoding


class Replica(process):
    def setup(client_processes, replica_id, signature, config):
        custom_log('INFO: Setting up Replica {}'.format(self.replica_id))
        self.mode = Mode.ACTIVE
        self.history = []
        self.running_state = config['initial_running_state']
        signing_key = config['replica_sks'][self.replica_id]
        self.factory = Message(self.replica_id)
        self.sign = lambda x: signing_key.sign(x)
        self.replica_processes = None
        self.is_head = self.replica_id == 1
        self.is_tail = self.replica_id == self.config['replica_count']
        self.head = None
        self.next_replica = None
        self.prev_replica = None
        self.slot = Slot()
        self.result_shuttle_cache = {}
        self.olympus = None
        self.head_timeout = (config['head_timeout']/1000)
        self.non_head_timeout = (config['nonhead_timeout']/1000)
        self.current_configuration = 1
        self.checkpointed_slot = 0
        self.cached_result = {}

        # For Demo
        self.client_request_count = {cid: 0 for cid in self.client_processes.keys()}
        self.client_request_count[0] = 0
        self.forward_request_count = {cid: 0 for cid in self.client_processes.keys()}
        self.forward_request_count[0] = 0
        self.request_shuttle_count = {cid: 0 for cid in self.client_processes.keys()}
        self.request_shuttle_count[0] = 0
        self.result_shuttle_count = {cid: 0 for cid in self.client_processes.keys()}
        self.result_shuttle_count[0] = 0
        self.outgoing_request_shuttle_count = {cid: 0 for cid in self.client_processes.keys()}
        self.outgoing_request_shuttle_count[0] = 0
        self.outgoing_result_shuttle_count = {cid: 0 for cid in self.client_processes.keys()}
        self.outgoing_result_shuttle_count[0] = 0
        failure_scenarios = config['failure_scenarios']
        self.failures = failure_scenarios.get((self.current_configuration, self.replica_id), {})
        self.checkpoint_count = 0
        self.completed_checkpoint_count = 0
        self.running_state_count = 0
        self.wedge_message_count = 0
        self.catchup_message_count = 0

    def run():
        custom_log('INFO: Started Replica {}'.format(self.replica_id))

        # FOR DEMO PURPOSE
        outfile = 'replica_state_{}.json'.format(self.replica_id)
        testutil.persist_state(self.running_state.value, outfile)

        await(some(received(('configuration_response', _,))))
        await(False)

    def receive(msg=('configuration_response', payload)):
        if 'status' in payload and payload['status'] == "reconfigure":
            custom_log('INFO: Replica Reconfiguring ... Received New Configuration from Olympus')
        else:
            custom_log('INFO: Received New Configuration from Olympus')
        self.olympus = payload['olympus']
        self.current_configuration = payload['configuration']
        self.replica_processes = payload['replicas']
        self.head = self.replica_processes[1]
        self.next_replica = None if self.is_tail else self.replica_processes[self.replica_id + 1]
        self.prev_replica = None if self.is_head else self.replica_processes[self.replica_id - 1]

    def receive(msg=('request', payload)):
        if self.is_head:
            client_id, request_id, signed_payload = payload['client_id'], payload['request_id'], payload['payload']
            is_verified, operation = self.signature.verify_client(client_id, signed_payload)
            if is_verified:
                custom_log('INFO: Received Client {} Request, Payload: {}'.format(client_id, operation))
                custom_log('INFO: Client Signature Verification Successful!')
                self.client_request_count[0] += 1
                self.client_request_count[client_id] += 1
                request_count = self.client_request_count[client_id]
                if (client_id, request_count, 'client_request', 'drop') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Drop, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    return
                if (client_id, request_count, 'client_request', 'crash') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Crash, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    testutil.crash()
                    return
                # TODO: Parameterize Truncate History, ie. Drop only n statements in history
                if (client_id, request_count, 'client_request', 'truncate_history') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Truncate History, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.wedge_message_count + 1
                    n = self.failures[client_id, request_count, 'client_request', 'truncate_history']
                    self.failures[(0, failure_request_count, 'wedge_request', 'truncate_history')] = n
                    custom_log('INFO: In the next outgoing wedged message, omit (truncate) last entry in history')
                if (client_id, request_count, 'client_request', 'increment_slot') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Increment Slot), Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    next(self.slot)
                    custom_log('INFO: Injected Failure: slot was incremented!')
                if (client_id, request_count, 'client_request', 'extra_op') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Extra Op, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    testutil.extra_op(self.running_state)
                    custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
                    custom_log('INFO: Modified Running State: {}'.format(self.running_state))
                if (client_id, request_count, 'client_request', 'change_result') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Change Result, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
                    self.failures[(0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'change_result')] = None
                    custom_log('INFO: Replica adds invalid result in the next outgoing result shuttle')
                if (client_id, request_count, 'client_request', 'drop_result_stmt') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Drop Result Statement, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
                    key = (0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'drop_result_stmt')
                    self.failures[key] = None
                    custom_log('INFO: Replica drops Head\'s result statement in the next outgoing result shuttle')
                if (client_id, request_count, 'client_request', 'change_operation') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Change Operation, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.outgoing_request_shuttle_count[0] + 1
                    self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
                    custom_log('INFO: Replica adds invalid operation in the next outgoing request shuttle')
                if (client_id, request_count, 'client_request', 'invalid_order_sig') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Invalid Order Sig, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.outgoing_request_shuttle_count[0] + 1
                    self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
                    custom_log(
                        'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
                if (client_id, request_count, 'client_request', 'invalid_result_sig') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Client Request: Invalid Result Sig, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.outgoing_request_shuttle_count[0] + 1
                    self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_result_sig')] = None
                    custom_log(
                        'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its result statement')
                handle_new_request(client_id, request_id, operation, signed_payload)
            else:
                custom_log('INFO: Not Verified Client {} Request'.format(client_id))

    def receive(msg=('forward_request', payload)):
        if self.is_head:
            custom_log('INFO: Replica is Head')
            sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
            is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                custom_log('INFO: Head Verification of the forwarded request complete.')
                client_id, request_id, client_signed_payload = payload['client_id'], payload['request_id'], payload[
                    'signed_payload']
                log_msg = 'INFO: Received Forward Request from Replica {}, Client: {} RequestID: {}'
                custom_log(log_msg.format(sender_replica_id, client_id, request_id))
                self.forward_request_count[0] += 1
                self.forward_request_count[client_id] += 1
                request_count = self.forward_request_count[client_id]
                if (client_id, request_count, 'forwarded_request', 'drop') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Drop, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    return
                if (client_id, request_count, 'forwarded_request', 'crash') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Crash, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    testutil.crash()
                    return
                if (client_id, request_count, 'forwarded_request', 'truncate_history') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Truncate History, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.wedge_message_count + 1
                    n = self.failures[(client_id, request_count, 'forwarded_request', 'truncate_history')]
                    self.failures[(0, failure_request_count, 'wedge_request', 'truncate_history')] = n
                    custom_log('INFO: In the next outgoing wedged message, omit (truncate) last entry in history')
                if (client_id, request_count, 'forwarded_request', 'sleep') in self.failures:
                    sleep_time = self.failures[(client_id, request_count, 'forwarded_request', 'sleep')]
                    log_msg = 'Injecting Failure: Forwarded Request: Sleep for {} milliseconds, Client: {} Message: {}'
                    custom_log(log_msg.format(sleep_time, client_id, request_count))
                    testutil.sleep(sleep_time)
                if (client_id, request_count, 'forwarded_request', 'increment_slot') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Increment Slot), Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    next(self.slot)
                    custom_log('INFO: Injected Failure: slot was incremented!')
                if (client_id, request_count, 'forwarded_request', 'extra_op') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Extra Op, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    testutil.extra_op(self.running_state)
                    custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
                    custom_log('INFO: Modified Running State: {}'.format(self.running_state))
                if (client_id, request_count, 'forwarded_request', 'change_result') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Change Result, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
                    self.failures[(0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'change_result')] = None
                    custom_log('INFO: Replica adds invalid result in the next outgoing result shuttle')
                if (client_id, request_count, 'forwarded_request', 'drop_result_stmt') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Drop Result Statement, Client:{} Message:{}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
                    key = (0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'drop_result_stmt')
                    self.failures[key] = None
                    custom_log('INFO: Replica drops Head\'s result statement in the next outgoing result shuttle')
                if (client_id, request_count, 'forwarded_request', 'change_operation') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Change Operation, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.outgoing_request_shuttle_count[0] + 1
                    self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
                    custom_log('INFO: Replica adds invalid operation in the next outgoing request shuttle')
                if (client_id, request_count, 'forwarded_request', 'invalid_order_sig') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Invalid Order Sig, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.outgoing_request_shuttle_count[0] + 1
                    self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
                    custom_log(
                        'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
                if (client_id, request_count, 'forwarded_request', 'invalid_result_sig') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Forwarded Request: Invalid Result Sig, Client: {} Message: {}'
                    custom_log(log_msg.format(client_id, request_count))
                    failure_request_count = self.outgoing_request_shuttle_count[0] + 1
                    self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_result_sig')] = None
                    custom_log(
                        'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
                operation = payload['operation']
                output_cache()
                custom_log('INFO: Verifying Operation ... ')
                is_verified = verify_operation(client_id, operation, client_signed_payload)
                if not is_verified:
                    self.mode = Mode.IMMUTABLE
                    proof_of_misbehaviour = 'Operation Verification Failed'
                    send_reconfiguration_request(proof_of_misbehaviour)
                else:
                    if (client_id, request_id) in self.result_shuttle_cache:
                        custom_log('INFO: Checking if Result present in Cache ...')
                        handle_recognized_request(client_id, request_id)
                    else:
                        custom_log('INFO: Head does not recognize this operation...')
                        custom_log('INFO: Head treats this as a new request (case 3 of the paper) ...')
                        handle_new_request(client_id, request_id, operation, client_signed_payload)

    def receive(msg=('request_shuttle', payload)):
        if not self.is_head:
            sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
            is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                custom_log('INFO: OrderStatement and Shuttle signature verification successful')
                log_msg = 'INFO: Received Request Shuttle from Replica {}, Payload: {}'
                custom_log(log_msg.format(sender_replica_id, payload))
                prev_req_shuttle = self.factory.parse_request_shuttle(payload)
                handle_request_shuttle(prev_req_shuttle)

    def receive(msg=('retransmission', payload)):
        client_id, request_id, signed_payload = payload['client_id'], payload['request_id'], payload['payload']
        is_verified, operation = self.signature.verify_client(client_id, signed_payload)
        log_msg = 'INFO: Received Client: {} Retransmission Request, Payload: {}'
        custom_log(log_msg.format(client_id, operation))
        if is_verified:
            custom_log('INFO: Client request signature verification successful!')
            if self.mode == Mode.IMMUTABLE:
                custom_log('INFO: Replica Immutable. Sending Error to Client !')
                error = 'ERROR - SERVER IS RECONFIGURING ...'
                error_response = self.factory.new_error_response(serialize_and_sign(error))
                custom_log('INFO: {}'.format(error_response))
                send_error_to_client(client_id, error_response)
            else:
                custom_log('INFO: Handling Retransmission Request...')
                handle_retransmission_request(client_id, request_id, operation, signed_payload)

    def receive(msg=('result_shuttle', payload)):
        sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
        is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
        log_msg = 'INFO: Received Result Shuttle from Replica: {}, Payload: {}'
        custom_log(log_msg.format(sender_replica_id, payload))
        if is_verified:
            custom_log('INFO: Result shuttle signature verification successful')
            result_shuttle = self.factory.parse_result_shuttle(payload)
            handle_result_shuttle(result_shuttle)

    def handle_new_request(client_id, request_id, operation, signed_operation):
        custom_log('INFO: Handling New Request ... ')
        custom_log('INFO: Running state before applying Operation:')
        output_running_state()
        request_count = self.client_request_count[client_id]
        if (client_id, request_count, 'client_request', 'sleep') in self.failures:
            sleep_time = self.failures[(client_id, request_count, 'client_request', 'sleep')]
            log_msg = 'Injecting Failure: Client Request Sleep for {} milliseconds, Client: {} Message: {}'
            custom_log(log_msg.format(sleep_time, client_id, request_count))
            testutil.sleep(sleep_time)
        next_slot = next(self.slot)
        custom_log('INFO: Assigning new slot: {}'.format(next_slot))
        original_operation = operation
        self.outgoing_request_shuttle_count[0] += 1
        self.outgoing_request_shuttle_count[client_id] += 1
        outgoing_shuttle_count = self.outgoing_request_shuttle_count[0]
        if (0, outgoing_shuttle_count, 'outgoing_shuttle', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure: Outgoing Request Shuttle: Change Operation, Outgoing Shuttle Count: {}'
            custom_log(log_msg.format(outgoing_shuttle_count))
            custom_log('INFO: Before Operation: {}'.format(operation))
            operation = testutil.change_operation()
            custom_log('INFO: After Operation: {}'.format(operation))
        order_statement = self.factory.new_order_statement(operation, next_slot)
        signed_order_statement = serialize_and_sign(order_statement)
        if (0, outgoing_shuttle_count, 'outgoing_shuttle', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Outgoing Request Shuttle: Invalid Order Sig, Outgoing Shuttle Count: {}'
            custom_log(log_msg.format(outgoing_shuttle_count))
            signed_order_statement = fake_serialize_and_sign(order_statement)
        new_order_proof_details = {
            'client_id': client_id,
            'request_id': request_id,
            'slot': next_slot,
            'operation': original_operation,
            'configuration': self.current_configuration,
            'order_statements': []
        }

        result = op.apply_operation(self.running_state, original_operation)
        self.cached_result[client_id] = {'request_id': request_id, 'operation': original_operation, 'result': result}
        empty_order_proof = self.factory.OrderProof(**new_order_proof_details)
        order_proof = self.factory.new_order_proof(empty_order_proof, signed_order_statement)
        result_statement = self.factory.new_result_statement(operation, result)
        signed_result_statement = serialize_and_sign(result_statement)
        if (0, outgoing_shuttle_count, 'outgoing_shuttle', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Outgoing Request Shuttle: Invalid Result Sig, Shuttle Count: {}'
            custom_log(log_msg.format(outgoing_shuttle_count))
            signed_result_statement = fake_serialize_and_sign(result_statement)
        new_result_proof_details = {
            'client_id': client_id,
            'request_id': request_id,
            'result': result_statement['result'],
            'operation': original_operation,
            'configuration': self.current_configuration,
            'result_statements': []
        }
        custom_log('INFO: Adding Result Statement with Result: {}'.format(result))
        empty_result_proof = self.factory.ResultProof(**new_result_proof_details)
        result_proof = self.factory.new_result_proof(empty_result_proof, signed_result_statement)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof,
                                   'signed_operation': signed_operation}
        request_shuttle = self.factory.new_request_shuttle(serialize_and_sign(request_shuttle_payload))
        self.result_shuttle_cache[(client_id, request_id)] = None
        history_order_proof = order_proof
        history_order_proof['signed_operation'] = signed_operation
        self.history.append(history_order_proof)
        custom_log('INFO: Order Proof (with signed order statements): {}'.format(order_proof))
        custom_log('INFO: Result Proof (with signed result statements): {}'.format(result_proof))
        forward_request_shuttle(request_shuttle)
        custom_log('INFO: Running state after applying Operation:')
        output_running_state()
        initiate_checkpoint_protocol(next_slot, operation)
        # FOR DEMO PURPOSE
        outfile = 'replica_state_{}.json'.format(self.replica_id)
        testutil.persist_state(self.running_state.value, outfile)

    def handle_retransmission_request(client_id, request_id, operation, signed_operation):
        custom_log('INFO: Retransmission Request, RID:{}, Client: {}'.format(request_id, client_id))
        custom_log('INFO: Checking if Result present in Cache (Case 1)...')
        if (client_id, request_id) not in self.result_shuttle_cache:
            custom_log('INFO: Request was not recognized (Case 2/3), Request : {}'.format(request_id))
            handle_unrecognized_request(client_id, request_id, operation, signed_operation)
        handle_recognized_request(client_id, request_id)

    def handle_recognized_request(client_id, request_id):

        def is_recognized_request():
            return (client_id, request_id) in self.result_shuttle_cache

        def is_result_shuttle_present():
            return self.result_shuttle_cache[(client_id, request_id)] is not None

        custom_log('INFO: Start Retransmission Response timer after recognizing the request (CASE 2) ...')
        req_timeout = self.head_timeout if self.is_head else self.non_head_timeout
        if await(is_recognized_request() and is_result_shuttle_present()):
            custom_log('INFO: Result Shuttle available in cache, Request: {}'.format(request_id))
            result_shuttle = self.result_shuttle_cache[(client_id, request_id)]
            result, result_proof = result_shuttle.result, result_shuttle.result_proof._asdict()
            self.outgoing_result_shuttle_count[0] += 1
            self.outgoing_result_shuttle_count[client_id] += 1
            outgoing_shuttle_count = self.outgoing_result_shuttle_count[0]
            if (0, outgoing_shuttle_count, 'outgoing_result_shuttle', 'change_result') in self.failures:
                log_msg = 'INFO: Injecting Failure: Outgoing Result Shuttle: Change Result, Shuttle Count: {}'
                custom_log(log_msg.format(outgoing_shuttle_count))
                custom_log('INFO: Old Result: {}'.format(result))
                result = testutil.change_result()
                custom_log('INFO: New Result: {}'.format(result))
            if (0, outgoing_shuttle_count, 'outgoing_result_shuttle', 'drop_result_stmt') in self.failures:
                log_msg = 'INFO: Injecting Failure: Outgoing Result Shuttle: Drop Result Statement, Shuttle Count: {}'
                custom_log(log_msg.format(outgoing_shuttle_count))
                custom_log('INFO: Old Result Statements Length: {}'.format(len(result_proof['result_statements'])))
                result_proof = testutil.drop_result_stmt(result_proof)
                custom_log('INFO: New Result Statements Length: {}'.format(len(result_proof['result_statements'])))
            result_shuttle_payload = {'result': result, 'result_proof': result_proof}
            signed_result_shuttle_payload = serialize_and_sign(result_shuttle_payload)
            custom_log('INFO: Signed Result Shuttle : {}'.format(signed_result_shuttle_payload))
            send_response_to_client(client_id, signed_result_shuttle_payload)
        elif timeout(req_timeout):
            custom_log('INFO: Replica timer expired (CASE 2)')
            custom_log('INFO: Replica changed to IMMUTABLE')
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Retransmission Request Timed Out'
            send_reconfiguration_request(proof_of_misbehaviour)

    def handle_unrecognized_request(client_id, request_id, operation, signed_operation):
        if self.is_head:
            custom_log('INFO: Head does not recognize the operation. Treating it as new request (CASE 3)...')
            handle_new_request(client_id, request_id, operation, signed_operation)
        else:
            forward_request_payload = {'client_id': client_id, 'request_id': request_id, 'operation': operation,
                                       'signed_payload': signed_operation}
            forward_request = self.factory.new_forward_request(serialize_and_sign(forward_request_payload))
            forward_to_head(forward_request)
            custom_log('INFO: Forward Request Payload: {}'.format(forward_request_payload))

    def handle_request_shuttle(prev_req_shuttle):
        custom_log('INFO: Replica received a request shuttle ... ')
        prev_order_proof, prev_result_proof = prev_req_shuttle.order_proof, prev_req_shuttle.result_proof
        client_id, request_id = prev_order_proof.client_id, prev_order_proof.request_id
        self.request_shuttle_count[0] += 1
        self.request_shuttle_count[client_id] += 1
        request_count = self.request_shuttle_count[client_id]
        if (client_id, request_count, 'shuttle', 'crash') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Crash, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            testutil.crash()
            return
        if (client_id, request_count, 'shuttle', 'drop') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Drop, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            return
        if (client_id, request_count, 'shuttle', 'truncate_history') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Truncate History, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.wedge_message_count + 1
            n = self.failures[(client_id, request_count, 'shuttle', 'truncate_history')]
            self.failures[(0, failure_request_count, 'wedge_request', 'truncate_history')] = n
            custom_log('INFO: In the next outgoing wedged message, omit (truncate) last entry in history')
        if (client_id, request_count, 'shuttle', 'extra_op') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Extra Op, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            testutil.extra_op(self.running_state)
            custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
            custom_log('INFO: Modified Running State: {}'.format(self.running_state))
        if (client_id, request_count, 'shuttle', 'change_result') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Change Result, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
            self.failures[(0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'change_result')] = None
            custom_log('INFO: Replica adds invalid result in the next outgoing result shuttle')
        if (client_id, request_count, 'shuttle', 'drop_result_stmt') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Drop Result Statement, Client:{} Message:{}'
            custom_log(log_msg.format(client_id, request_count))
            failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
            key = (0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'drop_result_stmt')
            self.failures[key] = None
            custom_log('INFO: Replica drops Head\'s result statement in the next outgoing result shuttle')
        if (client_id, request_count, 'shuttle', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Change Operation, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
            custom_log('INFO: Replica adds invalid operation in the next outgoing request shuttle')
        if (client_id, request_count, 'shuttle', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Invalid Order Sig, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
            custom_log(
                'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
        if (client_id, request_count, 'shuttle', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Invalid Result Sig, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_result_sig')] = None
            custom_log(
                'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
        is_verified = verify_order_proof(prev_order_proof)
        next_slot = next(self.slot)
        if not is_verified:
            custom_log('INFO: Replica changed to IMMUTABLE')
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Order Proof Verification failed'
            send_reconfiguration_request(proof_of_misbehaviour)
            return
        if prev_order_proof.slot != next_slot:
            custom_log('INFO: Replica changed to IMMUTABLE')
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Slot Hole Found'
            send_reconfiguration_request(proof_of_misbehaviour)
            return

        custom_log('INFO: Order statements verification (inside the request shuttle) successful')
        custom_log('INFO: Running state before applying Operation:')
        output_running_state()
        original_operation = prev_order_proof.operation
        operation = original_operation
        custom_log('INFO: Verifying Operation ... ')
        signed_operation = prev_req_shuttle.signed_operation
        is_verified = verify_operation(client_id, original_operation, signed_operation)
        if not is_verified:
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Operation Verification Failed'
            send_reconfiguration_request(proof_of_misbehaviour)
            return
        if (client_id, request_count, 'shuttle', 'sleep') in self.failures:
            sleep_time = self.failures[(client_id, request_count, 'shuttle', 'sleep')]
            log_msg = 'INFO: Injecting Failure: Request Shuttle: Sleep for {} milliseconds, Client: {} Message: {}'
            custom_log(log_msg.format(sleep_time, client_id, request_count))
            testutil.sleep(sleep_time)

        original_operation = operation
        self.outgoing_request_shuttle_count[0] += 1
        self.outgoing_request_shuttle_count[client_id] += 1
        outgoing_shuttle_count = self.outgoing_request_shuttle_count[0]
        if (0, outgoing_shuttle_count, 'outgoing_shuttle', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure: Outgoing Request Shuttle: Change Operation, Outgoing Shuttle Count: {}'
            custom_log(log_msg.format(outgoing_shuttle_count))
            custom_log('INFO: Before Operation: {}'.format(operation))
            operation = testutil.change_operation()
            custom_log('INFO: After Operation: {}'.format(operation))

        order_statement = self.factory.new_order_statement(operation, prev_order_proof.slot)
        signed_order_statement = serialize_and_sign(order_statement)
        if (0, outgoing_shuttle_count, 'outgoing_shuttle', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Outgoing Request Shuttle: Invalid Order Sig, Outgoing Shuttle Count: {}'
            custom_log(log_msg.format(outgoing_shuttle_count))
            signed_order_statement = fake_serialize_and_sign(order_statement)
        order_proof = self.factory.new_order_proof(prev_order_proof, signed_order_statement)
        result = op.apply_operation(self.running_state, original_operation)
        self.cached_result[client_id] = {'request_id': request_id, 'operation': original_operation, 'result': result}

        result_statement = self.factory.new_result_statement(operation, result)
        signed_result_statement = serialize_and_sign(result_statement)
        if (0, outgoing_shuttle_count, 'outgoing_shuttle', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Outgoing Request Shuttle: Invalid Result Sig, Shuttle Count: {}'
            custom_log(log_msg.format(outgoing_shuttle_count))
            signed_result_statement = fake_serialize_and_sign(result_statement)
        result_proof = self.factory.new_result_proof(prev_result_proof, signed_result_statement)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof,
                                   'signed_operation': signed_operation}
        request_shuttle = self.factory.new_request_shuttle(serialize_and_sign(request_shuttle_payload))
        self.result_shuttle_cache[(client_id, request_id)] = None
        history_order_proof = order_proof
        history_order_proof['signed_operation'] = signed_operation
        self.history.append(history_order_proof)
        custom_log('INFO: Order Proof (with signed order statements): {}'.format(order_proof))
        custom_log('INFO: Result Proof (with signed result statements): {}'.format(result_proof))
        forward_request_shuttle(request_shuttle)
        if self.is_tail:
            self.outgoing_result_shuttle_count[0] += 1
            self.outgoing_result_shuttle_count[client_id] += 1
            outgoing_shuttle_count = self.outgoing_result_shuttle_count[0]
            if (0, outgoing_shuttle_count, 'outgoing_result_shuttle', 'change_result') in self.failures:
                log_msg = 'INFO: Injecting Failure: Outgoing Result Shuttle: Change Result, Shuttle Count: {}'
                custom_log(log_msg.format(outgoing_shuttle_count))
                custom_log('INFO: Old Result: {}'.format(result))
                result = testutil.change_result()
                custom_log('INFO: New Result: {}'.format(result))
            if (0, outgoing_shuttle_count, 'outgoing_result_shuttle', 'drop_result_stmt') in self.failures:
                log_msg = 'INFO: Injecting Failure: Outgoing Result Shuttle: Drop Result Statement, Shuttle Count: {}'
                custom_log(log_msg.format(outgoing_shuttle_count))
                custom_log('INFO: Old Result Statements Length: {}'.format(len(result_proof['result_statements'])))
                result_proof = testutil.drop_result_stmt(result_proof)
                custom_log('INFO: New Result Statements Length: {}'.format(len(result_proof['result_statements'])))
            result_shuttle_payload = serialize_and_sign({'result': result, 'result_proof': result_proof})
            result_shuttle = self.factory.new_result_shuttle(result_shuttle_payload)
            # FOR DEMO: order changed
            custom_log('INFO: TAIL: Forwarding result to client. Forwarding result shuttle back in the chain.')
            custom_log('INFO: Signed Result Shuttle: {}'.format(result_shuttle_payload))
            forward_result_shuttle(result_shuttle)
            send_response_to_client(client_id, result_shuttle_payload)
        custom_log('INFO: Running state after applying Operation:')
        output_running_state()

        # FOR DEMO PURPOSE
        outfile = 'replica_state_{}.json'.format(self.replica_id)
        testutil.persist_state(self.running_state.value, outfile)

    def handle_result_shuttle(result_shuttle):
        custom_log('INFO: Handling result shuttle ...')
        result_proof = result_shuttle.result_proof
        result = result_shuttle.result
        client_id, request_id = result_proof.client_id, result_proof.request_id
        self.result_shuttle_count[0] += 1
        self.result_shuttle_count[client_id] += 1
        request_count = self.result_shuttle_count[client_id]
        if (client_id, request_count, 'result_shuttle', 'crash') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Crash, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            testutil.crash()
            return
        if (client_id, request_count, 'result_shuttle', 'truncate_history') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Truncate History, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.wedge_message_count + 1
            n = self.failures[(client_id, request_count, 'result_shuttle', 'truncate_history')]
            self.failures[(0, failure_request_count, 'wedge_request', 'truncate_history')] = n
            custom_log('INFO: In the next outgoing wedged message, omit (truncate) last entry in history')
        if (client_id, request_count, 'result_shuttle', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Invalid Order Sig, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
            custom_log(
                'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
        if (client_id, request_count, 'result_shuttle', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Change Operation, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
            custom_log('INFO: Replica adds invalid operation in the next outgoing request shuttle')
        if (client_id, request_count, 'result_shuttle', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Invalid Result Sig, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_result_sig')] = None
            custom_log(
                'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
        if (client_id, request_count, 'result_shuttle', 'drop') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Drop, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            return
        if (client_id, request_count, 'result_shuttle', 'extra_op') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Extra Op, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            testutil.extra_op(self.running_state)
            custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
            custom_log('INFO: Modified Running State: {}'.format(self.running_state))
        if (client_id, request_count, 'result_shuttle', 'change_result') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Change Result, Client: {} Message: {}'
            custom_log(log_msg.format(client_id, request_count))
            failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
            self.failures[(0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'change_result')] = None
            custom_log('INFO: Replica adds invalid result in the next outgoing result shuttle')
        if (client_id, request_count, 'result_shuttle', 'drop_result_stmt') in self.failures:
            log_msg = 'INFO: Injecting Failure: Result Shuttle: Drop Result Statement, Client:{} Message:{}'
            custom_log(log_msg.format(client_id, request_count))
            failure_result_shuttle_count = self.outgoing_result_shuttle_count[0] + 1
            key = (0, failure_result_shuttle_count, 'outgoing_result_shuttle', 'drop_result_stmt')
            self.failures[key] = None
            custom_log('INFO: Replica drops Head\'s result statement in the next outgoing result shuttle')
        if (client_id, request_count, 'result_shuttle', 'sleep') in self.failures:
            sleep_time = self.failures[(client_id, request_count, 'result_shuttle', 'sleep')]
            log_msg = 'Injecting Failure: Result Request: Sleep for {} milliseconds, Client: {} Message: {}'
            custom_log(log_msg.format(sleep_time, client_id, request_count))
            testutil.sleep(sleep_time)
        result_proof = result_proof._asdict()
        is_verified = verify_result_statements(result, result_proof['result_statements'])
        if is_verified:
            custom_log('INFO: Result Shuttle Verified... Caching Result ...')
            result = result_shuttle.result
            self.result_shuttle_cache[(client_id, request_id)] = result_shuttle
            if not self.is_head:
                self.outgoing_result_shuttle_count[0] += 1
                self.outgoing_result_shuttle_count[client_id] += 1
                outgoing_shuttle_count = self.outgoing_result_shuttle_count[0]
                if (0, outgoing_shuttle_count, 'outgoing_result_shuttle', 'change_result') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Outgoing Result Shuttle: Change Result, Shuttle Count: {}'
                    custom_log(log_msg.format(outgoing_shuttle_count))
                    custom_log('INFO: Old Result: {}'.format(result))
                    result = testutil.change_result()
                    custom_log('INFO: New Result: {}'.format(result))
                if (0, outgoing_shuttle_count, 'outgoing_result_shuttle', 'drop_result_stmt') in self.failures:
                    log_msg = 'INFO: Injecting Failure: Outgoing Result Shuttle: Drop Result Statement, Shuttle Count: {}'
                    custom_log(log_msg.format(outgoing_shuttle_count))
                    custom_log('INFO: Old Result Statements Length: {}'.format(len(result_proof['result_statements'])))
                    result_proof = testutil.drop_result_stmt(result_proof)
                    custom_log('INFO: New Result Statements Length: {}'.format(len(result_proof['result_statements'])))

            result_shuttle_payload = {'result': result, 'result_proof': result_proof}
            result_shuttle = self.factory.new_result_shuttle(serialize_and_sign(result_shuttle_payload))
            custom_log('INFO: Result shuttle to be forwarded: {}'.format(result_shuttle_payload))
            forward_result_shuttle(result_shuttle)
        else:
            custom_log('INFO: Result Proof Verification Failed !')
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Result Proof Verification Failed'
            send_reconfiguration_request(proof_of_misbehaviour)

    def initiate_checkpoint_protocol(slot, operation):
        if self.is_head:
            custom_log('INFO: Slot Number is: {}'.format(slot))
            if slot % self.config['checkpt_interval'] == 0:
                custom_log('INFO: Initiating Checkpoint Protocol...')
                new_checkpoint_proof_details = {'checkpoint_statements': []}
                empty_checkpoint_proof = self.factory.CheckpointProof(**new_checkpoint_proof_details)
                replica_running_state = self.running_state
                signed_running_state = serialize_and_sign(replica_running_state)
                custom_log('INFO: Head started checkpointing ...')
                checkpoint_proof = self.factory.new_checkpoint_proof(empty_checkpoint_proof, signed_running_state, slot)
                checkpoint_req_payload = {'checkpoint_proof': checkpoint_proof}
                checkpoint_request = self.factory.new_checkpoint_request(serialize_and_sign(checkpoint_req_payload))
                forward_checkpoint_request(checkpoint_request)

    def receive(msg=('checkpoint_shuttle', payload)):
        custom_log('INFO: Replica Received a CheckPoint Proof')
        self.checkpoint_count += 1
        request_count = self.checkpoint_count
        all_good = True
        # self.failures = [(2, 'checkpoint', 'replace_me'), (12, 'garbage', 'garbage')]
        if (request_count, 'checkpoint', 'crash') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: crash())'
            custom_log(log_msg.format(request_count))
            custom_log('INFO: Replica about to crash')
            testutil.crash()
        if (request_count, 'checkpoint', 'sleep') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: sleep())'
            custom_log(log_msg.format(request_count))
            n = self.failures[request_count, 'checkpoint', 'sleep']
            testutil.sleep(n)
            custom_log('INFO: Replica awake again after sleep')
        if (request_count, 'checkpoint', 'drop') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: drop())'
            custom_log(log_msg.format(request_count))
            if testutil.drop('checkpoint') == 'ignore_messages':
                all_good = False
            custom_log('INFO: Replica {} dropped the checkpoint proof!'.format(self.replica_id))
        if (request_count, 'checkpoint', 'extra_op') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: extra_op())'
            custom_log(log_msg.format(request_count))
            testutil.extra_op(self.running_state)
            custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
            custom_log('INFO: Modified Running State: {}'.format(self.running_state))
        if (request_count, 'checkpoint', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: invalid_order_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
            custom_log('INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')
        if (request_count, 'checkpoint', 'truncate_history') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: truncate_history())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.wedge_message_count + 1
            n = self.failures[(request_count, 'checkpoint', 'truncate_history')]
            self.failures[(0, failure_request_count, 'wedge_request', 'truncate_history')] = n
            custom_log('INFO: In the next outgoing wedged message, omit (truncate) last {} entry(s) in history'.format(n))
        if (request_count, 'checkpoint', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: change_operation())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
            custom_log('INFO: Replica uses get("x") as the operation in the next outgoing shuttle')
        if (request_count, 'checkpoint', 'change_result') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: change_result())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'change_result')] = None
            custom_log('INFO: Replica uses the hash of "OK" in the next outgoing result shuttle')
        if (request_count, 'checkpoint', 'drop_result_stmt') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: drop_result_stmt())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'drop_result_stmt')] = None
            custom_log('INFO: Replica omit the heads result statement from the result proof '
                       'in the next outgoing result shuttle')
        if (request_count, 'checkpoint', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: invalid_result_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'invalid_result_sig')] = None
            custom_log('INFO: In the next outgoing shuttle message, '
                       'replica puts an invalid signature on its result statement')
        if (request_count, 'checkpoint', 'drop_checkpt_stmts') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: drop_checkpt_stmts())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.completed_checkpoint_count + 1
            self.failures[(failure_request_count, 'completed_checkpoint', 'drop_checkpt_stmts')] = None
            custom_log('INFO: In the next outgoing completed checkpoint proof, '
                       'omits the first t+1 checkpoint statements')
        if not self.is_head and all_good:
            sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
            is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                custom_log('INFO: CheckPoint Proof signature verification successful')
                log_msg = 'INFO: Received CheckPoint Proof from Replica {}, Payload: {}'
                custom_log(log_msg.format(sender_replica_id, payload))
                prev_checkpoint_proof = self.factory.parse_checkpoint_request(payload)
                handle_checkpoint_proof(prev_checkpoint_proof)

    def handle_checkpoint_proof(prev_checkpoint_proof):
        # To-Do: Verification
        is_verified = verify_checkpoint_proof(prev_checkpoint_proof)
        if is_verified:
            custom_log('INFO: Checkpoint Proof Verification Successful')
            replica_running_state = self.running_state
            signed_running_state = serialize_and_sign(replica_running_state)
            checkpoint_proof = self.factory.new_checkpoint_proof(prev_checkpoint_proof, signed_running_state,
                                                                 self.slot.get_slot())
            checkpoint_req_payload = {'checkpoint_proof': checkpoint_proof}
            checkpoint_request = self.factory.new_checkpoint_request(serialize_and_sign(checkpoint_req_payload))
            forward_checkpoint_request(checkpoint_request)
            if self.is_tail:
                custom_log('INFO: Checkpoint Proof has reached TAIL!')
                custom_log('INFO: Checkpoint Proof :{}'.format(checkpoint_proof))
                checkpoint_res_payload = checkpoint_req_payload
                custom_log('INFO: Completed checkpoint Proof will now be sent back upstream along the chain')
                checkpoint_result = self.factory.new_checkpoint_result(serialize_and_sign(checkpoint_res_payload))
                truncate_history(checkpoint_proof)
                persist_checkpoint_info(checkpoint_proof['checkpoint_statements'])
                forward_checkpoint_result(checkpoint_result)

    def receive(msg=('checkpoint_result_shuttle', payload)):
        custom_log('INFO: Replica Received a completed CheckPoint Proof back.')
        self.completed_checkpoint_count += 1
        request_count = self.completed_checkpoint_count
        all_good = True
        # self.failures = [(2, 'completed_checkpoint', 'increment_slot'), (12, 'garbage', 'garbage')]
        # TODO: FIX compile time errors, ex: request_shuttle_count[0] => self.request_shuttle_count[0]
        if (request_count, 'completed_checkpoint', 'crash') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: crash())'
            custom_log(log_msg.format(request_count))
            custom_log('INFO: Replica about to crash')
            testutil.crash()
        if (request_count, 'completed_checkpoint', 'sleep') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: sleep())'
            custom_log(log_msg.format(request_count))
            n = self.failures[(request_count, 'completed_checkpoint', 'sleep')]
            testutil.sleep(n)
            custom_log('INFO: Replica Awake again after Sleep')
        if (request_count, 'completed_checkpoint', 'drop') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: drop())'
            custom_log(log_msg.format(request_count))
            if testutil.drop('completed_checkpoint') == 'ignore_messages':
                all_good = False
            custom_log('INFO: Replica {} dropped the checkpoint proof!'.format(self.replica_id))
        if (request_count, 'completed_checkpoint', 'increment_slot') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: increment_slot())'
            custom_log(log_msg.format(request_count))
            if self.is_head:
                next(self.slot)
                custom_log('INFO: Injected Failure: slot was incremented!')
            else:
                custom_log('INFO: Replica is not the head. Failure Injection has no effect')
        if (request_count, 'completed_checkpoint', 'extra_op') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: extra_op())'
            custom_log(log_msg.format(request_count))
            testutil.extra_op(self.running_state)
            custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
            custom_log('INFO: Modified Running State: {}'.format(self.running_state))
        if (request_count, 'completed_checkpoint', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: invalid_order_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
            custom_log('INFO: In the next outgoing shuttle message, '
                       'replica puts an invalid signature on its order statement')
        if (request_count, 'completed_checkpoint', 'truncate_history') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: truncate_history())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.wedge_message_count + 1
            n = self.failures[(request_count, 'completed_checkpoint', 'truncate_history')]
            self.failures[(0, failure_request_count, 'wedge_request', 'truncate_history')] = n
            custom_log('INFO: In the next outgoing wedged message, omit (truncate) last {} entry(s) in history'.format(n))
        if (request_count, 'completed_checkpoint', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: change_operation())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
            custom_log('INFO: Replica uses get("x") as the operation in the next outgoing shuttle')
        if (request_count, 'completed_checkpoint', 'change_result') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: change_result())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'change_result')] = None
            custom_log('INFO: Replica uses the hash of "OK" in the next outgoing result shuttle')
        if (request_count, 'completed_checkpoint', 'drop_result_stmt') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: completed_checkpoint({}), Failure: drop_result_stmt())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'drop_result_stmt')] = None
            custom_log('INFO: Replica omit the heads result statement from the result proof '
                       'in the next outgoing result shuttle')
        if (request_count, 'completed_checkpoint', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: invalid_result_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'invalid_result_sig')] = None
            custom_log('INFO: In the next outgoing shuttle message, '
                       'replica puts an invalid signature on its result statement')
        if not self.is_tail and all_good:
            sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
            is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                custom_log('INFO: Completed Checkpointproof signature verification successful')
                log_msg = 'INFO: Received Completed Checkpointproof from Replica {}, Payload: {}'
                custom_log(log_msg.format(sender_replica_id, payload))
                next_checkpoint_proof = payload['checkpoint_proof']
                handle_completed_checkpoint_proof(next_checkpoint_proof)
            else:
                custom_log('INFO: Completed Checkpoint Proof Verification failed')
                custom_log('INFO: Raising reconfiguration request')
                self.mode = Mode.IMMUTABLE
                proof_of_misbehaviour = 'Checkpoint Proof Verification Failed'
                send_reconfiguration_request(proof_of_misbehaviour)

    def handle_completed_checkpoint_proof(next_checkpoint_proof):
        is_valid_checkpoint = validate_completed_checkpoint(next_checkpoint_proof)
        if is_valid_checkpoint and not self.is_tail:
            custom_log('INFO: Completed Checkpoint Proof validation successful')
            custom_log('INFO: At least "t" number replicas have added checkpoint proofs')
            checkpoint_res_payload = {'checkpoint_proof': next_checkpoint_proof}
            checkpoint_result = self.factory.new_checkpoint_result(serialize_and_sign(checkpoint_res_payload))
            truncate_history(next_checkpoint_proof)
            persist_checkpoint_info(next_checkpoint_proof['checkpoint_statements'])
            request_count = self.completed_checkpoint_count
            if (request_count, 'completed_checkpoint', 'drop_checkpt_stmts') in self.failures:
                log_msg = 'INFO: Injecting Failure. (Trigger: checkpoint({}), Failure: drop_checkpt_stmts())'
                custom_log(log_msg.format(request_count))
                r_statements = next_checkpoint_proof['checkpoint_statements']
                tampered_r_statements = testutil.drop_checkpoint_statements(r_statements, self.config['replica_count'])
                next_checkpoint_proof['checkpoint_statements'] = tampered_r_statements
                checkpoint_res_payload = {'checkpoint_proof': next_checkpoint_proof}
                checkpoint_result = self.factory.new_checkpoint_result(serialize_and_sign(checkpoint_res_payload))
            forward_checkpoint_result(checkpoint_result)
        if not is_valid_checkpoint:
            custom_log('INFO: Completed Checkpoint Proof Validation failed')
            custom_log('INFO: Raising reconfiguration request')
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Checkpoint Proof Validation Failed'
            send_reconfiguration_request(proof_of_misbehaviour)

    def forward_checkpoint_request(checkpoint_request):
        if not self.is_tail:
            custom_log('INFO: Forwarding checkpoint proof to Replica: {}'.format(self.replica_id + 1))
            send(checkpoint_request, to=self.next_replica)

    def forward_checkpoint_result(checkpoint_result):
        if not self.is_head:
            custom_log('INFO: Forwarding completed checkpoint proof back to Replica: {}'.format(self.replica_id - 1))
            send(checkpoint_result, to=self.prev_replica)

    def receive(msg=('wedge_request', payload)):
        custom_log('INFO: Replica received a wedge request from Olympus')
        self.wedge_message_count += 1
        request_count = self.wedge_message_count
        all_good = True
        if (request_count, 'wedge_request', 'crash') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: crash())'
            custom_log(log_msg.format(request_count))
            custom_log('INFO: Replica about to crash')
            testutil.crash()

        if (request_count, 'wedge_request', 'sleep') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: sleep())'
            custom_log(log_msg.format(request_count))
            n = self.failures[request_count, 'wedge_request', 'sleep']
            testutil.sleep(n)
            custom_log('INFO: Replica awake again after sleep')

        if (request_count, 'wedge_request', 'drop') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: drop())'
            custom_log(log_msg.format(request_count))
            if testutil.drop('wedge_request') == 'ignore_messages':
                all_good = False
            custom_log('INFO: Replica {} dropped the wedge request!'.format(self.replica_id))

        if (request_count, 'wedge_request', 'extra_op') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: extra_op())'
            custom_log(log_msg.format(request_count))
            testutil.extra_op(self.running_state)
            custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
            custom_log('INFO: Modified Running State: {}'.format(self.running_state))

        if (request_count, 'wedge_request', 'increment_slot') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: increment_slot())'
            custom_log(log_msg.format(request_count))
            if self.is_head:
                next(self.slot)
                custom_log('INFO: Injected Failure: slot was incremented!')
            else:
                custom_log('INFO: Replica is not the head. Failure Injection has no effect')

        if (request_count, 'wedge_request', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: invalid_order_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
            custom_log(
                'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')

        if (request_count, 'wedge_request', 'truncate_history') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: truncate_history())'
            custom_log(log_msg.format(request_count))
            n = self.failures[(request_count, 'wedge_request', 'truncate_history')]
            is_success, new_history = testutil.truncate_history(self.history, n)
            if is_success:
                self.history = new_history
                custom_log('INFO: Truncated last {} statements from history'.format(n))
            else:
                custom_log('INFO: Did not meet requirements for truncation')

        if (0, request_count, 'wedge_request', 'truncate_history') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: truncate_history())'
            custom_log(log_msg.format(request_count))
            n = self.failures[(0, request_count, 'wedge_request', 'truncate_history')]
            is_success, new_history = testutil.truncate_history(self.history, n)
            if is_success:
                self.history = new_history
                custom_log('INFO: Truncated last {} statements from history'.format(n))
            else:
                custom_log('INFO: Did not meet requirements for truncation')

        if (request_count, 'wedge_request', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: change_operation())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
            custom_log('INFO: Replica uses get("x") as the operation in the next outgoing shuttle')

        if (request_count, 'wedge_request', 'change_result') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: change_result())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'change_result')] = None
            custom_log('INFO: Replica uses the hash of "OK" in the next outgoing result shuttle')

        if (request_count, 'wedge_request', 'drop_result_stmt') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: drop_result_stmt())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'drop_result_stmt')] = None
            custom_log('INFO: Replica omit the heads result statement from the result proof '
                       'in the next outgoing result shuttle')

        if (request_count, 'wedge_request', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: invalid_result_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'invalid_result_sig')] = None
            custom_log('INFO: In the next outgoing shuttle message, '
                       'replica puts an invalid signature on its result statement')

        if (request_count, 'wedge_request', 'drop_checkpt_stmts') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: wedge_request({}), Failure: drop_checkpt_stmts())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.completed_checkpoint_count + 1
            self.failures[(failure_request_count, 'completed_checkpoint', 'drop_checkpt_stmts')] = None
            custom_log('INFO: In the next outgoing completed checkpoint proof, '
                       'omits the first t+1 checkpoint statements')
        if all_good:
            wedge_message = {
                'replica_id': self.replica_id,
                'history': self.history,
                'replica_config': self.current_configuration,
                'running_state': self.running_state,
                'checkpointed_slot': self.checkpointed_slot
            }
            signed_wedge_message = serialize_and_sign(wedge_message)
            wedge_message_payload = {'replica_id': self.replica_id, 'payload': signed_wedge_message}
            custom_log('INFO: Sending wedge statement to Olympus')
            send(('wedge_message', wedge_message_payload), to=self.olympus)

    def receive(msg=('catch_up', payload)):
        custom_log('INFO: Received Catch Up Message from Olympus')
        self.catchup_message_count += 1
        request_count = self.catchup_message_count
        all_good = True
        if (request_count, 'catch_up', 'crash') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: crash())'
            custom_log(log_msg.format(request_count))
            custom_log('INFO: Replica about to crash')
            testutil.crash()

        if (request_count, 'catch_up', 'sleep') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: sleep())'
            custom_log(log_msg.format(request_count))
            n = self.failures[(request_count, 'catch_up', 'sleep')]
            testutil.sleep(n)
            custom_log('INFO: Replica awake again after sleep')

        if (request_count, 'catch_up', 'drop') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: drop())'
            custom_log(log_msg.format(request_count))
            if testutil.drop('catch_up') == 'ignore_messages':
                all_good = False
            custom_log('INFO: Replica {} dropped the catchup request!'.format(self.replica_id))

        if (request_count, 'catch_up', 'extra_op') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: extra_op())'
            custom_log(log_msg.format(request_count))
            testutil.extra_op(self.running_state)
            custom_log('INFO: Applied Extra Operation: put("a","a") to replica running state')
            custom_log('INFO: Modified Running State: {}'.format(self.running_state))

        if (request_count, 'catch_up', 'increment_slot') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: increment_slot())'
            custom_log(log_msg.format(request_count))
            if self.is_head:
                next(self.slot)
                custom_log('INFO: Injected Failure: slot was incremented!')
            else:
                custom_log('INFO: Replica is not the head. Failure Injection has no effect')

        if (request_count, 'catch_up', 'invalid_order_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: invalid_order_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'invalid_order_sig')] = None
            custom_log(
                'INFO: In the next outgoing shuttle message, replica puts an invalid signature on its order statement')

        if (request_count, 'catch_up', 'truncate_history') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: truncate_history())'
            custom_log(log_msg.format(request_count))
            n = self.failures[(request_count, 'catch_up', 'truncate_history')]
            self.failures[(0, request_count, 'wedge_request', 'truncate_history')] = n
            custom_log('INFO: Replica sends a truncated history by omitting the last {} entries'.format(n))

        if (request_count, 'catch_up', 'change_operation') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: change_operation())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.outgoing_request_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'outgoing_shuttle', 'change_operation')] = None
            custom_log('INFO: Replica uses get("x") as the operation in the next outgoing shuttle')

        if (request_count, 'catch_up', 'change_result') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: change_result())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'change_result')] = None
            custom_log('INFO: Replica uses the hash of "OK" in the next outgoing result shuttle')

        if (request_count, 'catch_up', 'drop_result_stmt') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: drop_result_stmt())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'drop_result_stmt')] = None
            custom_log('INFO: Replica omit the heads result statement from the result proof '
                       'in the next outgoing result shuttle')

        if (request_count, 'catch_up', 'invalid_result_sig') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: invalid_result_sig())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.result_shuttle_count[0] + 1
            self.failures[(0, failure_request_count, 'result_shuttle', 'invalid_result_sig')] = None
            custom_log('INFO: In the next outgoing shuttle message, '
                       'replica puts an invalid signature on its result statement')

        if (request_count, 'catch_up', 'drop_checkpt_stmts') in self.failures:
            log_msg = 'INFO: Injecting Failure. (Trigger: catch_up({}), Failure: drop_checkpt_stmts())'
            custom_log(log_msg.format(request_count))
            failure_request_count = self.completed_checkpoint_count + 1
            self.failures[(failure_request_count, 'completed_checkpoint', 'drop_checkpt_stmts')] = None
            custom_log('INFO: In the next outgoing completed checkpoint proof, '
                       'omits the first t+1 checkpoint statements')

        if all_good:
            operations_list = []
            for orderproof in payload:
                operations_list.append(orderproof['operation'])
            if not operations_list:
                custom_log('INFO: All operations are caught up')
            else:
                custom_log('INFO: Operations to catchup: {}'.format(operations_list))
            hashed_running_state = ''
            for operation in operations_list:
                result = op.apply_operation(self.running_state, operation)
            if len(payload) > 1:
                self.cached_result[payload[-1]['client_id']] = {'request_id': payload[-1]['request_id'],
                                                                'operation': payload[-1]['operation'], 'result': result}
            caught_up = {
                'hashed_running_state': self.running_state,
                'replica_id': self.replica_id,
                'replica_config': self.current_configuration,
                'cached_result': self.cached_result
            }
            custom_log('INFO: Sending caught up message to Olympus')
            send(('caught_up', caught_up), to=self.olympus)

    def receive(msg=('get_running_state', payload)):
        custom_log('INFO: Received "get running state" message from Olympus')
        self.running_state_count += 1
        request_count = self.running_state_count
        all_good = True


        if all_good:
            state = {
                'replica_id': self.replica_id,
                'replica_config': self.current_configuration,
                'running_state': self.running_state
            }
            custom_log('INFO: Sending hashed running state to Olympus')
            send(('running_state', state), to = self.olympus)


    def serialize_and_sign(payload):
        serialized_payload = pickle.dumps(payload)
        return self.sign(serialized_payload)

    def fake_serialize_and_sign(payload):
        serialized_payload = pickle.dumps(payload)
        fake_key = testutil.generate_fake_key()
        return fake_key.sign(serialized_payload)

    def forward_request_shuttle(request_shuttle):
        if not self.is_tail:
            custom_log('INFO: Forwarding Request Shuttle to Replica: {}'.format(self.replica_id + 1))
            send(request_shuttle, to=self.next_replica)

    def forward_result_shuttle(result_shuttle):
        if not self.is_head:
            custom_log('INFO: Forwarding Result Shuttle to Replica: {}'.format(self.replica_id - 1))
            send(result_shuttle, to=self.prev_replica)

    def forward_to_head(forward_request):
        custom_log('Sending Forward Request to Head')
        send(forward_request, to=self.head)

    def send_reconfiguration_request(proof_of_misbehaviour):
        custom_log('Raising Reconfiguration Request: {}'.format(proof_of_misbehaviour))
        type_ = 'replica'
        signed_message = serialize_and_sign(proof_of_misbehaviour)
        reconfig_request = self.factory.new_reconfiguration_request(type_, signed_message, self.current_configuration)
        send(reconfig_request, to=self.olympus)

    def send_response_to_client(client_id, result_shuttle):
        failure_injection()
        self.result_shuttle_count[client_id] += 1
        self.result_shuttle_count[0] += 1
        response = self.factory.new_response(result_shuttle)
        client_process = self.client_processes[client_id]
        send(response, to=client_process)
        custom_log('INFO: Responded to client with : {}'.format(result_shuttle))

    def send_error_to_client(client_id, error_response):
        client_process = self.client_processes[client_id]
        send(error_response, to=client_process)

    def truncate_history(checkpoint_proof):
        custom_log('History Before Truncating: {}'.format(self.history))
        custom_log('INFO: Truncating History ...')
        # list = [checkpoint['slot'] for checkpoint in checkpoint_proof['checkpoint_statements'] if checkpoint['replica_id'] == self.replica_id]
        list_of_slots = []
        for checkpoint in checkpoint_proof['checkpoint_statements']:
            if checkpoint['replica_id'] == self.replica_id:
                list_of_slots.append(checkpoint['slot'])
        if list_of_slots:
            new_history = [dict for dict in self.history if dict['slot'] > list_of_slots[0]]
            self.history = new_history
        custom_log('INFO: History After Truncating: {}'.format(self.history))

    def verify_checkpoint_proof(checkpoint_proof):
        custom_log('INFO: Checkpoint Proof Verification')
        # TODO - Verification logic
        return True

    def validate_completed_checkpoint(checkpoint_proof):
        number_of_failures_tolerable = (self.config['replica_count'] - 1) // 2
        if len(checkpoint_proof['checkpoint_statements']) <= number_of_failures_tolerable:
            return False
        checkpoint_statements = checkpoint_proof['checkpoint_statements']
        signed_running_state = {}
        checkpoint_slot = 0
        for statements in checkpoint_statements:
            if self.replica_id == statements['replica_id']:
                signed_running_state = statements['signed_running_state']
                checkpoint_slot = statements['slot']
        custom_log('INFO: (checkpoint_slot): {} '.format(checkpoint_slot))
        custom_log('INFO: (signed_running_state): {} '.format(signed_running_state))
        for statements in checkpoint_statements:
            if checkpoint_slot == statements['slot']:
                _, rs_1 = signature.verify_replica(self.replica_id, signed_running_state)
                is_verified, rs_2 = signature.verify_replica(statements['replica_id'],
                                                             statements['signed_running_state'])
                if not is_verified:
                    return False
                if rs_1 != rs_2:
                    return False
        return True

    def persist_checkpoint_info(checkpoint_statements):
        for statement in checkpoint_statements:
            if statement['replica_id'] == self.replica_id:
                self.checkpointed_slot = statement['slot']

    def verify_order_proof(order_proof):
        slot_number = order_proof.slot
        operation = order_proof.operation
        order_stmts = order_proof.order_statements
        prev_replica_count = self.replica_id - 1
        is_count_consistent = prev_replica_count == len(order_stmts)
        is_order_proof_verified = is_count_consistent
        for prev_replica_id, signed_order_stmt in enumerate(order_stmts):
            is_verified, order_stmt = self.signature.verify_replica(prev_replica_id + 1, signed_order_stmt)
            if not is_verified or slot_number != order_stmt['slot'] or operation != order_stmt['operation']:
                is_order_proof_verified = False
                break
        return is_order_proof_verified

    def verify_result_statements(result, signed_result_statements):
        results = []
        hashed_result = nacl.hash.sha256(bytes(result, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        for i, signed_result_statement in enumerate(signed_result_statements):
            rep_id = i + 1
            is_verified, result_statement = self.signature.verify_replica(rep_id, signed_result_statement)
            if not is_verified:
                return False
            results.append(result_statement['result'])
        return all(r == hashed_result for r in results)

    def verify_operation(client_id, operation, signed_operation):
        is_verified, unsigned_operation = self.signature.verify_client(client_id, signed_operation)
        custom_log('INFO: Operation Verification: {} == {}'.format(operation, unsigned_operation))
        return is_verified and unsigned_operation == operation

    def output_running_state():
        output('Replica: {} INFO: Running State: {}'.format(self.replica_id, self.running_state))

    def output_cache():
        output('INFO: cache contents:')
        formatter = lambda x: 'Client: {} Request: {} => Result: {}'.format(x[0][0], x[0][1], x[1])
        message = '\n'.join(map(formatter, self.result_shuttle_cache.items()))
        output('Replica {} : Cache: {}'.format(self.replica_id, message))

    def custom_log(log_message):
        output('Replica: {} {}'.format(self.replica_id, log_message))

    def receive(msg=('kill',)):
        custom_log('INFO: Terminating')
        testutil.crash()

    def failure_injection():
        # For Explicit Test Cases
        test_case = self.config.get('test_case', 0)
        if test_case == 2:
            if self.is_tail:
                output('Replica {} : Failure Injection: Sleep at Tail'.format(self.replica_id))
                time.sleep(5)
        return None
