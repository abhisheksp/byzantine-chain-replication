import pickle
import time

import testutil
import operation as op
from constants import Mode
from message import Message
from slot import Slot


class Replica(process):
    def setup(client_processes, replica_id, signature, config):
        self.mode = Mode.ACTIVE
        self.history = []
        self.running_state = config['initial_running_state']
        signing_key = config['replica_sks'][self.replica_id]
        self.factory = Message(self.replica_id)
        self.sign = lambda x: signing_key.sign(x)
        self.replica_processes = None
        self.is_head = self.replica_id == 1  # TODO: extract constant
        self.is_tail = self.replica_id == self.config['replica_count']
        self.head = None
        self.next_replica = None
        self.prev_replica = None
        self.slot = Slot()
        self.result_shuttle_cache = {}
        self.olympus = None
        self.head_timeout = config['head_timeout']
        self.non_head_timeout = config['nonhead_timeout']
        self.current_configuration = 0

        # For Demo
        self.client_request_count = {cid: 0 for cid in self.client_processes.keys()}
        self.forward_request_count = {cid: 0 for cid in self.client_processes.keys()}
        self.request_shuttle_count = {cid: 0 for cid in self.client_processes.keys()}
        self.result_shuttle_count = {cid: 0 for cid in self.client_processes.keys()}
        failure_scenarios = config['failure_scenarios']
        self.failures = failure_scenarios.get((self.current_configuration, self.replica_id), {})

    def run():
        custom_log('INFO: Started Replica {}'.format(self.replica_id))
        await(some(received(('new_configuration', _,))))
        await(False)

    def receive(msg=('new_configuration', payload)):
        custom_log('INFO: Received New Configuration from Olympus')
        failure_injection()
        self.olympus = payload['olympus']
        self.replica_processes = payload['replicas']
        # TODO: Extract Head Tail constant
        self.head = self.replica_processes[1]
        self.next_replica = None if self.is_tail else self.replica_processes[self.replica_id + 1]
        self.prev_replica = None if self.is_head else self.replica_processes[self.replica_id - 1]

    def receive(msg=('request', payload)):
        failure_injection()
        if self.is_head:
            client_id, request_id, signed_payload = payload['client_id'], payload['request_id'], payload['payload']
            is_verified, operation = self.signature.verify_client(client_id, signed_payload)
            if is_verified:
                custom_log('INFO: Received Client {} Request, Payload: {}'.format(client_id,
                                                                                  operation))
                handle_new_request(client_id, request_id, operation)
            else:
                custom_log('INFO: Not Verified Client {} Request'.format(client_id))

    def receive(msg=('forward_request', payload)):
        failure_injection()
        if self.is_head:
            sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
            is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                client_id, request_id = payload['client_id'], payload['request_id']
                custom_log('INFO: Received Forward Request from Replica {}, Client: {} RequestID: {}'.format(
                    sender_replica_id, client_id, request_id))
                self.forward_request_count[client_id] += 1
                request_count = self.forward_request_count[client_id]
                operation = payload['operation']
                if (client_id, request_count, 'forwarded_request', 'change_operation') in self.failures:
                    output('Replica {} : Injecting Failure: Change Operation, Client: {} Message: {}'.format(
                        self.replica_id, client_id,
                        request_count))
                    operation = testutil.change_operation()
                output_cache()
                if (client_id, request_id) in self.result_shuttle_cache:
                    handle_recognized_request(client_id, request_id)
                else:
                    handle_new_request(client_id, request_id, operation)

    def receive(msg=('request_shuttle', payload)):
        failure_injection()
        if not self.is_head:
            # TODO: sender_replica_id required?
            sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
            is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                custom_log('INFO: Orderstatement and Shuttle signature verification successful')
                custom_log('INFO: Received Request Shuttle from Replica {}, Payload: {}'.format(
                    sender_replica_id, payload))
                prev_req_shuttle = self.factory.parse_request_shuttle(payload)
                handle_request_shuttle(prev_req_shuttle)

    def receive(msg=('retransmission', payload)):
        failure_injection()
        client_id, request_id, signed_payload = payload['client_id'], payload['request_id'], payload['payload']
        is_verified, operation = self.signature.verify_client(client_id, signed_payload)
        if is_verified:

            custom_log('INFO: Received Client: {} Retransmission Request, Payload: {}'.format(
                client_id, operation))
            custom_log('INFO: Client request signature verification successful')
            if self.mode == Mode.IMMUTABLE:
                custom_log('INFO: Replica Immutable. Sending Error to Client...')
                error = 'ERROR'
                error_response = self.factory.new_error_response(serialize_and_sign(error))
                custom_log('INFO: {}'.format(error_response))
                send_error_to_client(client_id, error_response)
            else:
                custom_log('INFO: Handling Retransmission Request...')
                handle_retransmission_request(client_id, request_id, operation)

    def receive(msg=('result_shuttle', payload)):
        failure_injection()
        sender_replica_id, signed_payload = payload['replica_id'], payload['payload']
        is_verified, payload = self.signature.verify_replica(sender_replica_id, signed_payload)
        if is_verified:
            custom_log('INFO: Result shuttle signature verification successful')
            custom_log('INFO: Received Result Shuttle from Replica: {}, Payload: {}'.format(
                sender_replica_id, payload))
            result_shuttle = self.factory.parse_result_shuttle(payload)
            handle_result_shuttle(result_shuttle)

    def handle_new_request(client_id, request_id, operation):
        custom_log('INFO: Handling new Request ... ')
        custom_log('INFO: Running state before applying Operation:')
        output_running_state()
        self.client_request_count[client_id] += 1
        request_count = self.client_request_count[client_id]
        if (client_id, request_count, 'client_request', 'change_operation') in self.failures:
            output('Replica {} : Injecting Failure: Change Operation, Client: {} Message: {}'.format(self.replica_id,
                                                                                                     client_id,
                                                                                                     request_count))
            operation = testutil.change_operation()
        next_slot = next(self.slot)
        order_statement = self.factory.new_order_statement(operation, next_slot)
        signed_order_statement = serialize_and_sign(order_statement)
        new_order_proof_details = {
            'client_id': client_id,
            'request_id': request_id,
            'slot': next_slot,
            'operation': operation,
            'configuration': self.current_configuration,
            'order_statements': []
        }

        result = op.apply_operation(self.running_state, operation)

        if (client_id, request_count, 'client_request', 'change_result') in self.failures:
            output('Replica {} : Injecting Failure: Change Result, Client: {} Message: {}'.format(self.replica_id,
                                                                                                  client_id,
                                                                                                  request_count))
            result = testutil.change_result()
        empty_order_proof = self.factory.OrderProof(**new_order_proof_details)
        order_proof = self.factory.new_order_proof(empty_order_proof, signed_order_statement)
        result_statement = self.factory.new_result_statement(operation, result)
        signed_result_statement = serialize_and_sign(result_statement)
        new_result_proof_details = {
            'client_id': client_id,
            'request_id': request_id,
            'result': result_statement['result'],
            'operation': operation,
            'configuration': self.current_configuration,
            'result_statements': []
        }
        custom_log('INFO: Adding Result Statement with Result: {}'.format(result))
        empty_result_proof = self.factory.ResultProof(**new_result_proof_details)
        result_proof = self.factory.new_result_proof(empty_result_proof, signed_result_statement)
        if (client_id, request_count, 'client_request', 'drop_result_stmt') in self.failures:
            output('Replica {} : Injecting Failure: Drop Result Stmt, Client: {} Message: {}'.format(self.replica_id,
                                                                                                     client_id,
                                                                                                     request_count))
            result_proof = testutil.drop_result_stmt(result_proof)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof}
        request_shuttle = self.factory.new_request_shuttle(serialize_and_sign(request_shuttle_payload))
        self.result_shuttle_cache[(client_id, request_id)] = None
        self.history.append(order_proof)
        custom_log('INFO: Order Proof (with signed order statements): {}'.format(order_proof))
        custom_log('INFO: Result Proof (with signed result statements): {}'.format(result_proof))
        forward_request_shuttle(request_shuttle)
        custom_log('INFO: Running state after applying Operation:')
        output_running_state()

        # FOR DEMO PURPOSE
        outfile = 'replica_state_{}.json'.format(self.replica_id)
        testutil.persist_state(self.running_state.value, outfile)

    def handle_retransmission_request(client_id, request_id, operation):
        custom_log('INFO: Retransmission Request, RID:{}, Client: {}'.format(request_id, client_id))
        if (client_id, request_id) in self.result_shuttle_cache:
            handle_recognized_request(client_id, request_id)
        else:
            handle_unrecognized_request(client_id, request_id, operation)

    def handle_recognized_request(client_id, request_id):
        custom_log('INFO: Handle recognised request ... ')
        req_timeout = self.head_timeout if self.is_head else self.non_head_timeout
        if await(self.result_shuttle_cache[(client_id, request_id)] is not None):
            pass
        elif timeout(req_timeout):
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Recognized Request Timed Out'
            custom_log('INFO: Replica timed out after recognizing the request ... Raising reconfigure request ...')
            send_reconfiguration_request(proof_of_misbehaviour)
            return
        result_shuttle = self.result_shuttle_cache[(client_id, request_id)]
        result_shuttle_payload = serialize_and_sign({'result': result_shuttle.result,
                                                     'result_proof': result_shuttle.result_proof._asdict()})
        custom_log('INFO: Signed Result Shuttle : {}'.format(result_shuttle_payload))
        send_response_to_client(client_id, result_shuttle_payload)

    def handle_unrecognized_request(client_id, request_id, operation):
        if self.is_head:
            custom_log('INFO: Head does not recognize the operation. Treating it as new request')
            # Case: New Request
            handle_new_request(client_id, request_id, operation)
        else:
            forward_request_payload = {'client_id': client_id, 'request_id': request_id, 'operation': operation}
            forward_request = self.factory.new_forward_request(serialize_and_sign(forward_request_payload))
            forward_to_head(forward_request)
            custom_log('INFO: Forward Request Payload: {}'.format(forward_request_payload))

    def handle_request_shuttle(prev_req_shuttle):
        custom_log('INFO: Replica received a request shuttle ... ')
        prev_order_proof, prev_result_proof = prev_req_shuttle.order_proof, prev_req_shuttle.result_proof
        is_verified = verify_order_proof(prev_order_proof)
        next_slot = next(self.slot)
        if not is_verified or prev_order_proof.slot != next_slot:
            custom_log('INFO: Verification failed. Replica found a proof of misbehaviour ... ')
            proof_of_misbehaviour = 'Signature Verification Failed or Slot Hole found'
            self.mode = Mode.IMMUTABLE
            send_reconfiguration_request(proof_of_misbehaviour)
        custom_log('INFO: Order statements verification (inside the request shuttle) successful')
        custom_log('INFO: Running state before applying Operation:')
        output_running_state()
        client_id, request_id = prev_order_proof.client_id, prev_order_proof.request_id
        self.request_shuttle_count[client_id] += 1
        request_count = self.request_shuttle_count[client_id]
        operation = prev_order_proof.operation
        if (client_id, request_count, 'shuttle', 'change_operation') in self.failures:
            custom_log(
                'INFO: Injecting Failure: Change Operation, Client: {} Message: {}'.format(self.replica_id, client_id,
                                                                                           request_count))
            operation = testutil.change_operation()
        order_statement = self.factory.new_order_statement(operation, prev_order_proof.slot)
        signed_order_statement = serialize_and_sign(order_statement)
        order_proof = self.factory.new_order_proof(prev_order_proof, signed_order_statement)
        result = op.apply_operation(self.running_state, operation)
        if (client_id, request_count, 'shuttle', 'change_result') in self.failures:
            custom_log(
                'INFO: Injecting Failure: Change Result, Client: {} Message: {}'.format(self.replica_id, client_id,
                                                                                        request_count))
            result = testutil.change_result()

        result_statement = self.factory.new_result_statement(operation, result)
        signed_result_statement = serialize_and_sign(result_statement)
        result_proof = self.factory.new_result_proof(prev_result_proof, signed_result_statement)

        if (client_id, request_count, 'shuttle', 'drop_result_stmt') in self.failures:
            custom_log(
                'INFO: Injecting Failure: Drop Result Stmt, Client: {} Message: {}'.format(self.replica_id, client_id,
                                                                                           request_count))
            result_proof = testutil.drop_result_stmt(result_proof)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof}
        request_shuttle = self.factory.new_request_shuttle(serialize_and_sign(request_shuttle_payload))
        self.result_shuttle_cache[(client_id, request_id)] = None
        self.history.append(order_proof)
        custom_log('INFO: Order Proof (with signed order statements): {}'.format(order_proof))
        custom_log('INFO: Result Proof (with signed result statements): {}'.format(result_proof))
        forward_request_shuttle(request_shuttle)
        if self.is_tail:
            result_shuttle_payload = serialize_and_sign({'result': result, 'result_proof': result_proof})
            result_shuttle = self.factory.new_result_shuttle(result_shuttle_payload)
            # FOR DEMO: order changed
            custom_log(
                'INFO: Replica is a tail. Forwarding result to client. Forwarding result shuttle back in the chain.')
            custom_log('INFO: Signed Result Shuttle: {}'.format(result_shuttle_payload))
            forward_result_shuttle(result_shuttle)
            send_response_to_client(client_id, result_shuttle_payload)
        custom_log('INFO: Running state after applying Operation:')
        output_running_state()

        # FOR DEMO PURPOSE
        outfile = 'replica_state_{}.json'.format(self.replica_id)
        testutil.persist_state(self.running_state.value, outfile)

    def handle_result_shuttle(result_shuttle):
        custom_log('INFO: Handling result shuttle ...')
        result_proof = result_shuttle.result_proof
        client_id, request_id = result_proof.client_id, result_proof.request_id
        self.result_shuttle_count[client_id] += 1
        request_count = self.result_shuttle_count[client_id]
        result_proof = result_proof._asdict()
        if (client_id, request_count, 'result_shuttle', 'drop_result_stmt') in self.failures:
            output('Replica {} : Dropping Result Stmt, Client: {} Message: {}'.format(self.replica_id, client_id,
                                                                                      request_count))
            result_proof = testutil.drop_result_stmt(result_proof)
        is_verified = verify_result_statements_sign(result_proof['result_statements'])
        if is_verified:
            custom_log('INFO: Result Shuttle Verified... Caching Result ...')
            self.result_shuttle_cache[(client_id, request_id)] = result_shuttle
            result_shuttle_payload = {'result': result_shuttle.result,
                                      'result_proof': result_proof}
            result_shuttle = self.factory.new_result_shuttle(serialize_and_sign(result_shuttle_payload))
            custom_log('INFO: Result shuttle to be forwarded: {}'.format(result_shuttle_payload))
            forward_result_shuttle(result_shuttle)
        else:
            output('Replica {} : Result Proof Verification Failed'.format(self.replica_id, self.replica_id + 1))
            self.mode = Mode.IMMUTABLE
            proof_of_misbehaviour = 'Result Proof Verification Failed'
            send_reconfiguration_request(proof_of_misbehaviour)

    def serialize_and_sign(payload):
        serialized_payload = pickle.dumps(payload)
        return self.sign(serialized_payload)

    def forward_request_shuttle(request_shuttle):
        if not self.is_tail:
            custom_log(
                'INFO: Forwarding Request Shuttle to Replica: {}'.format(self.replica_id + 1))
            send(request_shuttle, to=self.next_replica)

    def forward_result_shuttle(result_shuttle):
        if not self.is_head:
            custom_log('INFO: Forwarding Result Shuttle to Replica: {}'.format(self.replica_id - 1))
            send(result_shuttle, to=self.prev_replica)

    def forward_to_head(forward_request):
        custom_log('Sending Forward Request to Head')
        send(forward_request, to=self.head)

    def send_reconfiguration_request(proof_of_misbehaviour):
        custom_log(' Raising Reconfiguration Request')
        type_ = 'replica'
        signed_message = serialize_and_sign(proof_of_misbehaviour)
        reconfig_request = self.factory.new_reconfiguration_request(type_, signed_message)
        send(reconfig_request, to=self.olympus)

    def send_response_to_client(client_id, result_shuttle):
        response = self.factory.new_response(result_shuttle)
        client_process = self.client_processes[client_id]
        send(response, to=client_process)
        custom_log("Responded to client with : {}".format(result_shuttle))

    def send_error_to_client(client_id, error_response):
        client_process = self.client_processes[client_id]
        send(error_response, to=client_process)

    def verify_order_proof(order_proof):
        slot_number = order_proof.slot
        operation = order_proof.operation
        order_stmts = order_proof.order_statements
        prev_replica_count = self.replica_id - 1
        is_count_consistent = prev_replica_count == len(order_stmts)
        is_order_proof_verified = is_count_consistent
        for prev_replica_id, signed_order_stmt in enumerate(order_stmts):
            is_verified, order_stmt = self.signature.verify_replica(prev_replica_id + 1, signed_order_stmt)
            if not is_verified or slot_number != order_stmt['slot'] or operation != order_stmt['operation']:
                is_order_proof_verified = False
                break
        custom_log('INFO: Order Proof verification True/False: {}'.format(is_order_proof_verified))
        return is_order_proof_verified

    def verify_result_statements_sign(signed_result_statements):
        for i, signed_result_statement in enumerate(signed_result_statements):
            rep_id = i + 1
            is_verified, result_statement = self.signature.verify_replica(rep_id, signed_result_statement)
            if not is_verified:
                return False
        return True

    def output_running_state():
        output('Replica: {} INFO: Running State: {}'.format(self.replica_id, self.running_state))

    def output_cache():
        formatter = lambda x: 'Client: {} Request: {} => Result: {}'.format(x[0][0], x[0][1], x[1])
        message = '\n'.join(map(formatter, self.result_shuttle_cache.items()))
        output('Replica {} : Cache: {}'.format(self.replica_id, message))

    def custom_log(log_message):
        output('Replica: {} {}'.format(self.replica_id, log_message))

    def failure_injection(type_=None):
        # For Explicit Test Cases
        if self.config['test_case'] == 2:
            output('Replica {} : Failure Injection: Sleep'.format(self.replica_id))
            time.sleep(10)
        return None
