# -*- generated by 1.0.9 -*-
import da
PatternExpr_354 = da.pat.TuplePattern([da.pat.ConstantPattern('new_configuration'), da.pat.FreePattern(None)])
PatternExpr_379 = da.pat.TuplePattern([da.pat.ConstantPattern('new_configuration'), da.pat.FreePattern('payload')])
PatternExpr_451 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('payload')])
PatternExpr_518 = da.pat.TuplePattern([da.pat.ConstantPattern('forward_request'), da.pat.FreePattern('payload')])
PatternExpr_605 = da.pat.TuplePattern([da.pat.ConstantPattern('request_shuttle'), da.pat.FreePattern('payload')])
PatternExpr_668 = da.pat.TuplePattern([da.pat.ConstantPattern('retransmission'), da.pat.FreePattern('payload')])
PatternExpr_770 = da.pat.TuplePattern([da.pat.ConstantPattern('result_shuttle'), da.pat.FreePattern('payload')])
_config_object = {}
import pickle
import testutil
from constants import Mode
from message import Message
from slot import Slot

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_354, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_379, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_378]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_451, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_450]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_518, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_517]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_605, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_604]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_668, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_667]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_770, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_769])])

    def setup(self, client_processes, replica_id, signature, config, **rest_1982):
        super().setup(client_processes=client_processes, replica_id=replica_id, signature=signature, config=config, **rest_1982)
        self._state.client_processes = client_processes
        self._state.replica_id = replica_id
        self._state.signature = signature
        self._state.config = config
        self._state.mode = Mode.ACTIVE
        self._state.history = []
        type = None
        self._state.running_state = self._state.config['initial_running_state']
        signing_key = self._state.config['replica_sks'][self._state.replica_id]
        self._state.factory = Message(self._state.replica_id)
        self._state.sign = (lambda x: signing_key.sign(x))
        self._state.replica_processes = None
        self._state.is_head = (self._state.replica_id == 1)
        self._state.is_tail = (self._state.replica_id == self._state.config['replica_count'])
        self._state.head = None
        self._state.next_replica = None
        self._state.prev_replica = None
        self._state.slot = Slot()
        self._state.result_shuttle_cache = {}
        self._state.olympus = None
        self._state.head_timeout = self._state.config['head_timeout']
        self._state.non_head_timeout = self._state.config['nonhead_timeout']

    def run(self):
        self.custom_log('INFO: Started Replica {}'.format(self._state.replica_id))
        super()._label('_st_label_351', block=False)

        def ExistentialOpExpr_352():
            for (_, _, (_ConstantPattern368_, _)) in self._ReplicaReceivedEvent_0:
                if (_ConstantPattern368_ == 'new_configuration'):
                    if True:
                        return True
            return False
        _st_label_351 = 0
        while (_st_label_351 == 0):
            _st_label_351 += 1
            if ExistentialOpExpr_352():
                _st_label_351 += 1
            else:
                super()._label('_st_label_351', block=True)
                _st_label_351 -= 1
        super()._label('_st_label_374', block=False)
        _st_label_374 = 0
        while (_st_label_374 == 0):
            _st_label_374 += 1
            if False:
                _st_label_374 += 1
            else:
                super()._label('_st_label_374', block=True)
                _st_label_374 -= 1

    def handle_new_request(self, client_id, request_id, operation):
        self.custom_log('INFO: Handling new Request ... ')
        self.custom_log('INFO: Running state before applying Operation:')
        self.output_running_state()
        next_slot = next(self._state.slot)
        order_statement = self._state.factory.new_order_statement(operation, next_slot)
        signed_order_statement = self.serialize_and_sign(order_statement)
        new_order_proof_details = {'client_id': client_id, 'request_id': request_id, 'slot': next_slot, 'operation': operation, 'configuration': 'DEFAULT', 'order_statements': []}
        result = self.apply_operation(operation)
        empty_order_proof = self._state.factory.OrderProof(**new_order_proof_details)
        order_proof = self._state.factory.new_order_proof(empty_order_proof, signed_order_statement)
        result_statement = self._state.factory.new_result_statement(operation, result)
        signed_result_statement = self.serialize_and_sign(result_statement)
        new_result_proof_details = {'client_id': client_id, 'request_id': request_id, 'result': result_statement['result'], 'operation': operation, 'configuration': 'DEFAULT', 'result_statements': []}
        empty_result_proof = self._state.factory.ResultProof(**new_result_proof_details)
        result_proof = self._state.factory.new_result_proof(empty_result_proof, signed_result_statement)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof}
        request_shuttle = self._state.factory.new_request_shuttle(self.serialize_and_sign(request_shuttle_payload))
        self._state.result_shuttle_cache[(client_id, request_id)] = None
        self._state.history.append(order_proof)
        self.custom_log('INFO: Order Proof (with signed order statements): {}'.format(order_proof))
        self.custom_log('INFO: Result Proof (with signed result statements): {}'.format(result_proof))
        self.forward_request_shuttle(request_shuttle)
        self.custom_log('INFO: Running state after applying Operation:')
        self.output_running_state()
        outfile = 'replica_state_{}.json'.format(self._state.replica_id)
        testutil.persist_state(self._state.running_state.value, outfile)

    def handle_retransmission_request(self, client_id, request_id, operation):
        self.custom_log('INFO: Retransmission Request, RID:{}, Client: {}'.format(request_id, client_id))
        if ((client_id, request_id) in self._state.result_shuttle_cache):
            self.handle_recognized_request(client_id, request_id)
        else:
            self.handle_unrecognized_request(client_id, request_id, operation)

    def handle_recognized_request(self, client_id, request_id):
        self.custom_log('INFO: Handle recognised request ... ')
        req_timeout = (self._state.head_timeout if self._state.is_head else self._state.non_head_timeout)
        super()._label('_st_label_1091', block=False)
        _st_label_1091 = 0
        self._timer_start()
        while (_st_label_1091 == 0):
            _st_label_1091 += 1
            if (not (self._state.result_shuttle_cache[(client_id, request_id)] is None)):
                pass
                _st_label_1091 += 1
            elif self._timer_expired:
                self._state.mode = Mode.IMMUTABLE
                proof_of_misbehaviour = 'Recognized Request Timed Out'
                self.custom_log('INFO: Replica timed out after recognizing the request ... Raising reconfigure request ...')
                self.send_reconfiguration_request(proof_of_misbehaviour)
                return
                _st_label_1091 += 1
            else:
                super()._label('_st_label_1091', block=True, timeout=req_timeout)
                _st_label_1091 -= 1
        result_shuttle = self._state.result_shuttle_cache[(client_id, request_id)]
        result_shuttle_payload = self.serialize_and_sign({'result': result_shuttle.result, 'result_proof': result_shuttle.result_proof._asdict()})
        self.custom_log('INFO: Signed Result Shuttle : {}'.format(result_shuttle_payload))
        self.respond_to_client(client_id, result_shuttle_payload)

    def handle_unrecognized_request(self, client_id, request_id, operation):
        if self._state.is_head:
            self.custom_log('INFO: Head does not recognize the operation. Treating it as new request')
            self.handle_new_request(client_id, request_id, operation)
        else:
            forward_request_payload = {'client_id': client_id, 'request_id': request_id, 'operation': operation}
            forward_request = self._state.factory.new_forward_request(self.serialize_and_sign(forward_request_payload))
            self.forward_to_head(forward_request)
            self.custom_log('INFO: Forward Request Payload: {}'.format(forward_request_payload))

    def parse_request_shuttle(self, payload):
        order_proof = self._state.factory.OrderProof(**payload['order_proof'])
        result_proof = self._state.factory.ResultProof(**payload['result_proof'])
        return self._state.factory.RequestShuttle(order_proof, result_proof)

    def parse_result_shuttle(self, payload):
        result = payload['result']
        result_proof = self._state.factory.ResultProof(**payload['result_proof'])
        return self._state.factory.ResultShuttle(result, result_proof)

    def handle_request_shuttle(self, prev_req_shuttle):
        self.custom_log('INFO: Replica received a request shuttle ... ')
        (prev_order_proof, prev_result_proof) = (prev_req_shuttle.order_proof, prev_req_shuttle.result_proof)
        is_verified = self.verify_order_proof(prev_order_proof)
        next_slot = next(self._state.slot)
        if ((not is_verified) or (not (prev_order_proof.slot == next_slot))):
            self.custom_log('INFO: Verification failed. Replica found a proof of misbehaviour ... ')
            proof_of_misbehaviour = 'Signature Verification Failed or Slot Hole found'
            self._state.mode = Mode.IMMUTABLE
            self.send_reconfiguration_request(proof_of_misbehaviour)
            return
        self.custom_log('INFO: Order statements verification (inside the request shuttle) successful')
        self.custom_log('INFO: Running state before applying Operation:')
        self.output_running_state()
        (client_id, request_id) = (prev_order_proof.client_id, prev_order_proof.request_id)
        operation = prev_order_proof.operation
        order_statement = self._state.factory.new_order_statement(prev_order_proof.operation, prev_order_proof.slot)
        signed_order_statement = self.serialize_and_sign(order_statement)
        order_proof = self._state.factory.new_order_proof(prev_order_proof, signed_order_statement)
        result = self.apply_operation(operation)
        result_statement = self._state.factory.new_result_statement(operation, result)
        signed_result_statement = self.serialize_and_sign(result_statement)
        result_proof = self._state.factory.new_result_proof(prev_result_proof, signed_result_statement)
        request_shuttle_payload = {'order_proof': order_proof, 'result_proof': result_proof}
        request_shuttle = self._state.factory.new_request_shuttle(self.serialize_and_sign(request_shuttle_payload))
        self._state.result_shuttle_cache[(client_id, request_id)] = None
        self._state.history.append(order_proof)
        self.custom_log('INFO: Order Proof (with signed order statements): {}'.format(order_proof))
        self.custom_log('INFO: Result Proof (with signed result statements): {}'.format(result_proof))
        self.forward_request_shuttle(request_shuttle)
        if self._state.is_tail:
            result_shuttle_payload = self.serialize_and_sign({'result': result, 'result_proof': result_proof})
            result_shuttle = self._state.factory.new_result_shuttle(result_shuttle_payload)
            self.custom_log('INFO: Replica is a tail. Forwarding result to client. Forwarding result shuttle back in the chain.')
            self.custom_log('INFO: Signed Result Shuttle: {}'.format(result_shuttle_payload))
            self.forward_result_shuttle(result_shuttle)
            self.respond_to_client(client_id, result_shuttle_payload)
        self.custom_log('INFO: Running state after applying Operation:')
        self.output_running_state()
        outfile = 'replica_state_{}.json'.format(self._state.replica_id)
        testutil.persist_state(self._state.running_state.value, outfile)

    def handle_result_shuttle(self, result_shuttle):
        self.custom_log('INFO: Handling result shuttle ...')
        result_proof = result_shuttle.result_proof
        self.custom_log('INFO: Result Shuttle Verified... Caching Result ...')
        (client_id, request_id) = (result_proof.client_id, result_proof.request_id)
        self._state.result_shuttle_cache[(client_id, request_id)] = result_shuttle
        result_shuttle_payload = {'result': result_shuttle.result, 'result_proof': result_shuttle.result_proof._asdict()}
        result_shuttle = self._state.factory.new_result_shuttle(self.serialize_and_sign(result_shuttle_payload))
        self.custom_log('INFO: Result shuttle to be forwarded: {}'.format(result_shuttle_payload))
        self.forward_result_shuttle(result_shuttle)

    def serialize_and_sign(self, payload):
        serialized_payload = pickle.dumps(payload)
        return self._state.sign(serialized_payload)

    def forward_request_shuttle(self, request_shuttle):
        if (not self._state.is_tail):
            self.custom_log('INFO: Forwarding Request Shuttle to Replica: {}'.format((self._state.replica_id + 1)))
            self.send(request_shuttle, to=self._state.next_replica)

    def forward_result_shuttle(self, result_shuttle):
        if (not self._state.is_head):
            self.custom_log('INFO: Forwarding Result Shuttle to Replica: {}'.format((self._state.replica_id - 1)))
            self.send(result_shuttle, to=self._state.prev_replica)

    def forward_to_head(self, forward_request):
        self.custom_log('Sending Forward Request to Head')
        self.send(forward_request, to=self._state.head)

    def send_reconfiguration_request(self, proof_of_misbehaviour):
        self.custom_log(' Raising Reconfiguration Request')
        type_ = 'replica'
        signed_message = self.serialize_and_sign(proof_of_misbehaviour)
        reconfig_request = self._state.factory.new_reconfiguration_request(type_, signed_message)
        self.send(reconfig_request, to=self._state.olympus)

    def apply_operation(self, payload):
        operation = payload['operation']
        if (operation == 'put'):
            return self._state.running_state.put(payload['key'], payload['val'])
        elif (operation == 'get'):
            return self._state.running_state.get(payload['key'])
        elif (operation == 'append'):
            return self._state.running_state.append(payload['key'], payload['val'])
        elif (operation == 'slice'):
            return self._state.running_state.slice(payload['key'], payload['slice'])

    def respond_to_client(self, client_id, result_shuttle):
        response = self._state.factory.new_response(result_shuttle)
        client_process = self._state.client_processes[client_id]
        self.send(response, to=client_process)
        self.custom_log('Responded to client with : {}'.format(result_shuttle))

    def verify_order_proof(self, order_proof):
        slot_number = order_proof.slot
        operation = order_proof.operation
        order_stmts = order_proof.order_statements
        prev_replica_count = (self._state.replica_id - 1)
        is_count_consistent = (prev_replica_count == len(order_stmts))
        is_order_proof_verified = is_count_consistent
        for (prev_replica_id, signed_order_stmt) in enumerate(order_stmts):
            (is_verified, order_stmt) = self._state.signature.verify_replica((prev_replica_id + 1), signed_order_stmt)
            if ((not is_verified) or (not (slot_number == order_stmt['slot'])) or (not (operation == order_stmt['operation']))):
                is_order_proof_verified = False
                break
        self.custom_log('INFO: Order Proof verification True/False: {}'.format(is_order_proof_verified))
        return is_order_proof_verified

    def output_running_state(self):
        self.output('Replica: {} INFO: Running State: {}'.format(self._state.replica_id, self._state.running_state))

    def output_cache(self):
        formatter = (lambda x: 'Client: {} Request: {} => Result: {}'.format(x[0][0], x[0][1], x[1]))
        message = '\n'.join(map(formatter, self._state.result_shuttle_cache.items()))
        self.output('Replica {} : Cache: {}'.format(self._state.replica_id, message))

    def custom_log(self, log_message):
        self.output('Replica: {} {}'.format(self._state.replica_id, log_message))

    def _Replica_handler_378(self, payload):
        self.custom_log('INFO: Received New Configuration from Olympus')
        self._state.olympus = payload['olympus']
        self._state.replica_processes = payload['replicas']
        self._state.head = self._state.replica_processes[1]
        self._state.next_replica = (None if self._state.is_tail else self._state.replica_processes[(self._state.replica_id + 1)])
        self._state.prev_replica = (None if self._state.is_head else self._state.replica_processes[(self._state.replica_id - 1)])
    _Replica_handler_378._labels = None
    _Replica_handler_378._notlabels = None

    def _Replica_handler_450(self, payload):
        if self._state.is_head:
            (client_id, request_id, signed_payload) = (payload['client_id'], payload['request_id'], payload['payload'])
            (is_verified, operation) = self._state.signature.verify_client(client_id, signed_payload)
            if is_verified:
                self.custom_log('INFO: Received Client {} Request, Payload: {}'.format(client_id, operation))
                self.handle_new_request(client_id, request_id, operation)
            else:
                self.custom_log('INFO: Not Verified Client {} Request'.format(client_id))
    _Replica_handler_450._labels = None
    _Replica_handler_450._notlabels = None

    def _Replica_handler_517(self, payload):
        if self._state.is_head:
            (sender_replica_id, signed_payload) = (payload['replica_id'], payload['payload'])
            (is_verified, payload) = self._state.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                (client_id, request_id) = (payload['client_id'], payload['request_id'])
                self.custom_log('INFO: Received Forward Request from Replica {}, Client: {} RequestID: {}'.format(sender_replica_id, client_id, request_id))
                operation = payload['operation']
                if ((client_id, request_id) in self._state.result_shuttle_cache):
                    self.handle_recognized_request(client_id, request_id)
                else:
                    self.handle_new_request(client_id, request_id, operation)
    _Replica_handler_517._labels = None
    _Replica_handler_517._notlabels = None

    def _Replica_handler_604(self, payload):
        if (not self._state.is_head):
            (sender_replica_id, signed_payload) = (payload['replica_id'], payload['payload'])
            (is_verified, payload) = self._state.signature.verify_replica(sender_replica_id, signed_payload)
            if is_verified:
                self.custom_log('INFO: Received Request Shuttle from Replica {}, Payload: {}'.format(sender_replica_id, payload))
                self.custom_log('INFO: Orderstatement and Shuttle signature verification successful')
                prev_req_shuttle = self.parse_request_shuttle(payload)
                self.handle_request_shuttle(prev_req_shuttle)
    _Replica_handler_604._labels = None
    _Replica_handler_604._notlabels = None

    def _Replica_handler_667(self, payload):
        (client_id, request_id, signed_payload) = (payload['client_id'], payload['request_id'], payload['payload'])
        (is_verified, operation) = self._state.signature.verify_client(client_id, signed_payload)
        if is_verified:
            self.custom_log('INFO: Received Client: {} Retransmission Request, Payload: {}'.format(client_id, operation))
            self.custom_log('INFO: Client request signature verification successful')
            if (self._state.mode == Mode.IMMUTABLE):
                self.custom_log('INFO: Replica Immutable. Sending Error to Client...')
                error = 'Proof of Misbehaviour'
                error_response = self._state.factory.new_error_response(self.serialize_and_sign(error))
                self.custom_log('INFO: {}'.format(error_response))
                self.respond_to_client(client_id, error_response)
            else:
                self.custom_log('INFO: Handling Retransmission Request...')
                self.handle_retransmission_request(client_id, request_id, operation)
    _Replica_handler_667._labels = None
    _Replica_handler_667._notlabels = None

    def _Replica_handler_769(self, payload):
        (sender_replica_id, signed_payload) = (payload['replica_id'], payload['payload'])
        (is_verified, payload) = self._state.signature.verify_replica(sender_replica_id, signed_payload)
        if is_verified:
            self.custom_log('Received Result Shuttle from Replica: {}, Payload: {}'.format(sender_replica_id, payload))
            self.custom_log('INFO: Result shuttle signature verification successful')
            result_shuttle = self.parse_result_shuttle(payload)
            self.handle_result_shuttle(result_shuttle)
    _Replica_handler_769._labels = None
    _Replica_handler_769._notlabels = None
