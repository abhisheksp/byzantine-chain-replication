# -*- generated by 1.0.9 -*-
import da
PatternExpr_298 = da.pat.TuplePattern([da.pat.ConstantPattern('new_configuration'), da.pat.FreePattern(None)])
PatternExpr_326 = da.pat.TuplePattern([da.pat.ConstantPattern('new_configuration'), da.pat.FreePattern('payload')])
PatternExpr_402 = da.pat.TuplePattern([da.pat.ConstantPattern('response'), da.pat.FreePattern('payload')])
_config_object = {}
import collections
import pickle
import nacl
import nacl.encoding
import nacl.exceptions
import nacl.hash
import operation as op
import testutil
from message import Message
from state import State

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_298, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_326, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_325]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_402, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_401])])

    def setup(self, client_id, signature, config, **rest_1047):
        super().setup(client_id=client_id, signature=signature, config=config, **rest_1047)
        self._state.client_id = client_id
        self._state.signature = signature
        self._state.config = config
        self._state.head = None
        self._state.olympus = None
        self._state.replica_processes = None
        self._state.replica_processes_set = None
        signing_key = self._state.config['client_sks'][self._state.client_id]
        self._state.sign = (lambda x: signing_key.sign(x))
        self._state.factory = Message(self._state.client_id)
        self._state.request_timeout = (self._state.config['client_timeout'] / 1000)
        self._state.pending_requests = set()
        self._state.majority_replica_count = None

    def run(self):
        self.custom_log('INFO: Client is up and running')
        self.custom_log('INFO: Initial State: (Pending_Requests: {})'.format(self._state.pending_requests))
        self.custom_log('INFO: Awaiting new configuration from Olympus')
        super()._label('_st_label_295', block=False)

        def ExistentialOpExpr_296():
            for (_, _, (_ConstantPattern312_, _)) in self._ClientReceivedEvent_0:
                if (_ConstantPattern312_ == 'new_configuration'):
                    if True:
                        return True
            return False
        _st_label_295 = 0
        while (_st_label_295 == 0):
            _st_label_295 += 1
            if ExistentialOpExpr_296():
                _st_label_295 += 1
            else:
                super()._label('_st_label_295', block=True)
                _st_label_295 -= 1
        self.demo()
        super()._label('_st_label_321', block=False)
        _st_label_321 = 0
        while (_st_label_321 == 0):
            _st_label_321 += 1
            if False:
                _st_label_321 += 1
            else:
                super()._label('_st_label_321', block=True)
                _st_label_321 -= 1

    def handle_response(self, payload):
        (result, result_proof) = (payload['result'], payload['result_proof'])
        is_verified = self.verify_result_proof(result, result_proof)
        if is_verified:
            self.custom_log('INFO: Response Accepted, Request ID: {}'.format(result_proof['request_id']))
        else:
            self.custom_log('INFO: Response Rejected, Result Proof Verification Failed')

    def send_request(self, operation, receiver):
        serialized_payload = self.serialize_and_sign(operation)
        request = self._state.factory.new_request(serialized_payload)
        request_id = request[1]['request_id']
        self._state.pending_requests.add(request_id)
        self.send(request, to=receiver)
        self.custom_log('INFO: Sending Request, RequestID: {}, Receiver: {}, Operation: {}'.format(request_id, receiver, operation))
        super()._label('_st_label_566', block=False)
        _st_label_566 = 0
        self._timer_start()
        while (_st_label_566 == 0):
            _st_label_566 += 1
            if (not (request_id in self._state.pending_requests)):
                pass
                _st_label_566 += 1
            elif self._timer_expired:
                self.custom_log('INFO: Request Timed Out')
                self.retransmit_request(request_id, operation)
                _st_label_566 += 1
            else:
                super()._label('_st_label_566', block=True, timeout=self._state.request_timeout)
                _st_label_566 -= 1

    def retransmit_request(self, old_request_id, operation):
        self.custom_log('INFO: Retransmitting Old Request, RequestID: {} '.format(old_request_id))
        payload = self.serialize_and_sign(operation)
        request = self._state.factory.new_retransmission_request(old_request_id, payload)
        self.send(request, to=self._state.replica_processes_set)
        super()._label('_st_label_620', block=False)
        _st_label_620 = 0
        self._timer_start()
        while (_st_label_620 == 0):
            _st_label_620 += 1
            if (not (old_request_id in self._state.pending_requests)):
                pass
                _st_label_620 += 1
            elif self._timer_expired:
                self.custom_log('INFO: Retransmission Timed Out, Request ID: {}'.format(old_request_id))
                _st_label_620 += 1
            else:
                super()._label('_st_label_620', block=True, timeout=self._state.request_timeout)
                _st_label_620 -= 1

    def serialize_and_sign(self, payload):
        serialized_payload = pickle.dumps(payload)
        return self._state.sign(serialized_payload)

    def verify_result_proof(self, result, result_proof):

        def verify_result_statements_sign(signed_result_statements):
            result_statements = []
            for (i, signed_result_statement) in enumerate(signed_result_statements):
                replica_id = (i + 1)
                (is_verified, result_statement) = self._state.signature.verify_replica(replica_id, signed_result_statement)
                if (not is_verified):
                    return (False, None)
                result_statements.append(result_statement)
            return (True, result_statements)

        def find_majority(result_hashes):
            counter = collections.Counter(result_hashes)
            majority_hash = None
            found_majority_count = 0
            for (h, count) in counter.items():
                if (count > found_majority_count):
                    found_majority_count = count
                    majority_hash = h
            return (majority_hash, found_majority_count)
        result_hash = nacl.hash.sha256(bytes(result, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        (is_verified, result_statements) = verify_result_statements_sign(result_proof['result_statements'])
        if (not is_verified):
            return False
        result_hashes = list(map((lambda r: r['result']), result_statements))
        (majority_hash, found_majority_count) = find_majority(result_hashes)
        required_majority_count = self._state.majority_replica_count
        is_required_majority = (found_majority_count >= required_majority_count)
        return (is_required_majority and (result_hash == majority_hash))

    def demo(self):
        verification_running_state = State()

        def apply_operation(state, payload):
            operation = payload['operation']
            if (operation == 'put'):
                return state.put(payload['key'], payload['val'])
            elif (operation == 'get'):
                return state.get(payload['key'])
            elif (operation == 'append'):
                return state.append(payload['key'], payload['val'])
            elif (operation == 'slice'):
                return state.slice(payload['key'], payload['slice'])

        def regular_client_workflow():
            client_workloads = self._state.config['client_workload'][self._state.client_id]
            for operation in client_workloads:
                apply_operation(verification_running_state, operation)
                self.send_request(operation, self._state.head)
            outfile = 'client_state_{}.json'.format(self._state.client_id)
            testutil.persist_state(verification_running_state.value, outfile)

        def demo_forward_requests():
            self.custom_log('INFO: Demoing Forwarding Request: Sending New Request to Nonhead Replica')
            operation = op.new_put_operation('movie', 'inception')
            apply_operation(verification_running_state, operation)
            non_head_replica = self._state.replica_processes[2]
            self.send_request(operation, non_head_replica)
            outfile = 'client_state_{}.json'.format(self._state.client_id)
            testutil.persist_state(verification_running_state.value, outfile)
        self.custom_log('INFO: Starting DEMO')
        test_case = self._state.config['test_case']
        if (test_case == 1):
            self.custom_log('INFO: Executing Test Case: 1(Single Client)')
            regular_client_workflow()
        if (test_case == 2):
            self.custom_log('INFO: Executing Test Case: 2(Multiple Client)')
            regular_client_workflow()
        elif (test_case == 3):
            self.custom_log('INFO: Executing Test Case: 3(Single Client: Forward Request)')
            demo_forward_requests()

    def custom_log(self, log_message):
        self.output('Client: {} {}'.format(self._state.client_id, log_message))

    def _Client_handler_325(self, payload):
        self.custom_log('INFO: Received New Configuration from Olympus')
        self._state.olympus = payload['olympus']
        self._state.replica_processes = payload['replicas']
        self._state.replica_processes_set = set(self._state.replica_processes.values())
        self._state.head = self._state.replica_processes[1]
        replica_count = len(self._state.replica_processes_set)
        self._state.majority_replica_count = ((replica_count // 2) + 1)
        self.custom_log('INFO: Storing Olympus and Replicas processes')
        self.custom_log('INFO: Initialized Majority Replica Count: {}'.format(self._state.majority_replica_count))
    _Client_handler_325._labels = None
    _Client_handler_325._notlabels = None

    def _Client_handler_401(self, payload):
        (replica_id, signed_payload) = (payload['replica_id'], payload['payload'])
        (is_verified, payload) = self._state.signature.verify_replica(replica_id, signed_payload)
        if is_verified:
            self.custom_log('INFO: Received Response from Replica: {}, Payload: {}'.format(replica_id, payload))
            result_proof = payload['result_proof']
            request_id = result_proof['request_id']
            if (request_id in self._state.pending_requests):
                self.handle_response(payload)
                self._state.pending_requests.remove(request_id)
            else:
                self.custom_log('INFO: Dropping Duplicate Response from Replica: {}, Payload: {}'.format(replica_id, payload))
    _Client_handler_401._labels = None
    _Client_handler_401._notlabels = None
