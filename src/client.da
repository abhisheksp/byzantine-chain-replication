import collections
import pickle

import nacl
import nacl.encoding
import nacl.exceptions
import nacl.hash
import util
from message import Message
from state import State


class Client(process):
    def setup(client_id, config):
        self.head = None
        self.olympus = None
        self.replica_processes = None
        self.replica_processes_set = None
        signing_key = config['client_sks'][client_id]
        self.sign = lambda x: signing_key.sign(x)
        self.verifying_key = config['client_vks'][client_id]
        self.olympus_vk = config['olympus_verifying_key']
        self.replica_vks = config['replica_vks']
        self.factory = Message(client_id)
        self.request_timeout = (config['client_timeout'] / 1000)
        self.pending_requests = set()
        self.majority_replica_count = None
        output('Client setup finished...')

    def run():
        output('Client is up...')
        output('awaiting new configuration from Olympus')
        await(some(received(('new_configuration', _,))))
        demo_requests()
        await(False)

    def receive(msg=('new_configuration', payload)):
        output('received new configuration from Olympus')
        self.olympus = payload['olympus']
        self.replica_processes = payload['replicas']
        self.replica_processes_set = set(self.replica_processes.values())
        self.head = self.replica_processes[1]
        replica_count = len(self.replica_processes_set)
        self.majority_replica_count = (replica_count // 2) + 1

    def receive(msg=('response', payload)):
        replica_id, signed_payload = payload['replica_id'], payload['payload']
        is_verified, payload = verify_replica(replica_id, signed_payload)
        if is_verified:
            output(
                'Client: {}, Received Response from Replica: {}, Payload:'.format(self.client_id, replica_id, payload))
            result_proof = payload['result_proof']
            request_id = result_proof['request_id']
            if request_id in self.pending_requests:
                output("Received Replica Response, Payload:", payload)
                handle_response(payload)
                self.pending_requests.remove(request_id)
            else:
                output("Dropping Duplicate Replica Response, Payload:", payload)

    def handle_response(payload):
        result, result_proof = payload['result'], payload['result_proof']
        is_verified = verify_result_proof(result, result_proof)
        if is_verified:
            output('Client {}: Response Accepted, Request ID: {}'.format(self.client_id, result_proof['request_id']))
        else:
            output('Client {}: Response Rejecting, Proof of Misbehaviour'.format(self.client_id))

    def send_request(operation):
        serialized_payload = serialize_and_sign(operation)
        request = self.factory.new_request(serialized_payload)
        request_id = request[1]['request_id']
        self.pending_requests.add(request_id)
        send(request, to=self.head)
        if await(request_id not in self.pending_requests):
            pass
        elif timeout(self.request_timeout):
            output('TimedOut, Issue Retransmission')
            retransmit_request(request_id, operation)

    def retransmit_request(old_request_id, operation):
        output('Client: Retransmitting old request: ', old_request_id)
        payload = serialize_and_sign(operation)
        request = self.factory.new_retransmission_request(old_request_id, payload)
        send(request, to=self.replica_processes_set)
        if await(old_request_id not in self.pending_requests):
            pass
        elif timeout(self.request_timeout):
            output('Retransmission Timed Out')

    def serialize_and_sign(payload):
        serialized_payload = pickle.dumps(payload)
        return self.sign(serialized_payload)

    def verify_replica(replica_id, signed_payload):
        try:
            if replica_id in self.replica_vks:
                serialized_payload = self.replica_vks[replica_id].verify(signed_payload)
                deserialized_payload = pickle.loads(serialized_payload)
                return True, deserialized_payload
            return False, None
        except nacl.exceptions.BadSignatureError:
            return False, None

    def verify_result_proof(result, result_proof):
        def verify_result_statements_sign(signed_result_statements):
            result_statements = []
            for i, signed_result_statement in enumerate(signed_result_statements):
                replica_id = i + 1
                is_verified, result_statement = verify_replica(replica_id, signed_result_statement)
                if not is_verified:
                    return False, None
                result_statements.append(result_statement)
            return True, result_statements

        def find_majority(result_hashes):
            counter = collections.Counter(result_hashes)
            majority_hash = None
            found_majority_count = 0
            for h, count in counter.items():
                if count > found_majority_count:
                    found_majority_count = count
                    majority_hash = h
            return majority_hash, found_majority_count

        result_hash = nacl.hash.sha256(bytes(result, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        is_verified, result_statements = verify_result_statements_sign(result_proof['result_statements'])
        if not is_verified:
            return False
        result_hashes = list(map(lambda r: r['result'], result_statements))
        majority_hash, found_majority_count = find_majority(result_hashes)
        required_majority_count = self.majority_replica_count
        is_required_majority = found_majority_count >= required_majority_count
        return is_required_majority and result_hash == majority_hash

    # FOR DEMO PURPOSES
    def demo_requests():
        def apply_operation(state, payload):
            operation = payload['operation']
            if operation == 'put':
                return state.put(payload['key'], payload['val'])
            elif operation == 'get':
                return state.get(payload['key'])
            elif operation == 'append':
                return state.append(payload['key'], payload['val'])
            elif operation == 'slice':
                return state.slice(payload['key'], payload['slice'])
                # TODO: handle unrecognized operation?

        verification_running_state = State()
        client_workloads = config['client_workload'][self.client_id]
        for op in client_workloads:
            apply_operation(verification_running_state, op)
            send_request(op)
        outfile = 'client_state_{}.json'.format(self.client_id)
        util.persist_state(verification_running_state.value, outfile)
